\input texinfo  @c -*-texinfo-*-
@c %**start of header
@setfilename ginac.info
@settitle GiNaC, an open framework for symbolic computation within the C++ programming language
@setchapternewpage on
@afourpaper
@c For `info' only.
@paragraphindent 0
@c For TeX only.
@iftex
@c I hate putting "@noindent" in front of every paragraph.
@parindent=0pt
@end iftex
@c %**end of header

@include version.texi

@direntry
* ginac: (ginac).                   C++ library for symbolic computation.
@end direntry

@ifinfo
This is a tutorial that documents GiNaC @value{VERSION}, an open
framework for symbolic computation within the C++ programming language.

Copyright (C) 1999-2002 Johannes Gutenberg University Mainz, Germany

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end ifinfo

@finalout
@c finalout prevents ugly black rectangles on overfull hbox lines
@titlepage
@title GiNaC @value{VERSION}
@subtitle An open framework for symbolic computation within the C++ programming language
@subtitle @value{UPDATED}
@author The GiNaC Group:
@author Christian Bauer, Alexander Frink, Richard Kreckel

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1999-2002 Johannes Gutenberg University Mainz, Germany
@sp 2
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.
@end titlepage

@page
@contents

@page


@node Top, Introduction, (dir), (dir)
@c    node-name, next, previous, up
@top GiNaC

This is a tutorial that documents GiNaC @value{VERSION}, an open
framework for symbolic computation within the C++ programming language.

@menu
* Introduction::                 GiNaC's purpose.
* A Tour of GiNaC::              A quick tour of the library.
* Installation::                 How to install the package.
* Basic Concepts::               Description of fundamental classes.
* Methods and Functions::        Algorithms for symbolic manipulations.
* Extending GiNaC::              How to extend the library.
* A Comparison With Other CAS::  Compares GiNaC to traditional CAS.
* Internal Structures::          Description of some internal structures.
* Package Tools::                Configuring packages to work with GiNaC.
* Bibliography::
* Concept Index::
@end menu


@node Introduction, A Tour of GiNaC, Top, Top
@c    node-name, next, previous, up
@chapter Introduction
@cindex history of GiNaC

The motivation behind GiNaC derives from the observation that most
present day computer algebra systems (CAS) are linguistically and
semantically impoverished.  Although they are quite powerful tools for
learning math and solving particular problems they lack modern
linguistic structures that allow for the creation of large-scale
projects.  GiNaC is an attempt to overcome this situation by extending a
well established and standardized computer language (C++) by some
fundamental symbolic capabilities, thus allowing for integrated systems
that embed symbolic manipulations together with more established areas
of computer science (like computation-intense numeric applications,
graphical interfaces, etc.) under one roof.

The particular problem that led to the writing of the GiNaC framework is
still a very active field of research, namely the calculation of higher
order corrections to elementary particle interactions.  There,
theoretical physicists are interested in matching present day theories
against experiments taking place at particle accelerators.  The
computations involved are so complex they call for a combined symbolical
and numerical approach.  This turned out to be quite difficult to
accomplish with the present day CAS we have worked with so far and so we
tried to fill the gap by writing GiNaC.  But of course its applications
are in no way restricted to theoretical physics.

This tutorial is intended for the novice user who is new to GiNaC but
already has some background in C++ programming.  However, since a
hand-made documentation like this one is difficult to keep in sync with
the development, the actual documentation is inside the sources in the
form of comments.  That documentation may be parsed by one of the many
Javadoc-like documentation systems.  If you fail at generating it you
may access it from @uref{http://www.ginac.de/reference/, the GiNaC home
page}.  It is an invaluable resource not only for the advanced user who
wishes to extend the system (or chase bugs) but for everybody who wants
to comprehend the inner workings of GiNaC.  This little tutorial on the
other hand only covers the basic things that are unlikely to change in
the near future.

@section License
The GiNaC framework for symbolic computation within the C++ programming
language is Copyright @copyright{} 1999-2002 Johannes Gutenberg
University Mainz, Germany.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,
MA 02111-1307, USA.


@node A Tour of GiNaC, How to use it from within C++, Introduction, Top
@c    node-name, next, previous, up
@chapter A Tour of GiNaC

This quick tour of GiNaC wants to arise your interest in the
subsequent chapters by showing off a bit.  Please excuse us if it
leaves many open questions.

@menu
* How to use it from within C++::  Two simple examples.
* What it can do for you::         A Tour of GiNaC's features.
@end menu


@node How to use it from within C++, What it can do for you, A Tour of GiNaC, A Tour of GiNaC
@c    node-name, next, previous, up
@section How to use it from within C++

The GiNaC open framework for symbolic computation within the C++ programming
language does not try to define a language of its own as conventional
CAS do.  Instead, it extends the capabilities of C++ by symbolic
manipulations.  Here is how to generate and print a simple (and rather
pointless) bivariate polynomial with some large coefficients:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y");
    ex poly;

    for (int i=0; i<3; ++i)
        poly += factorial(i+16)*pow(x,i)*pow(y,2-i);

    cout << poly << endl;
    return 0;
@}
@end example

Assuming the file is called @file{hello.cc}, on our system we can compile
and run it like this:

@example
$ c++ hello.cc -o hello -lcln -lginac
$ ./hello
355687428096000*x*y+20922789888000*y^2+6402373705728000*x^2
@end example

(@xref{Package Tools}, for tools that help you when creating a software
package that uses GiNaC.)

@cindex Hermite polynomial
Next, there is a more meaningful C++ program that calls a function which
generates Hermite polynomials in a specified free variable.

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

ex HermitePoly(const symbol & x, int n)
@{
    ex HKer=exp(-pow(x, 2));
    // uses the identity H_n(x) == (-1)^n exp(x^2) (d/dx)^n exp(-x^2)
    return normal(pow(-1, n) * diff(HKer, x, n) / HKer);
@}

int main()
@{
    symbol z("z");

    for (int i=0; i<6; ++i)
        cout << "H_" << i << "(z) == " << HermitePoly(z,i) << endl;

    return 0;
@}
@end example

When run, this will type out

@example
H_0(z) == 1
H_1(z) == 2*z
H_2(z) == 4*z^2-2
H_3(z) == -12*z+8*z^3
H_4(z) == -48*z^2+16*z^4+12
H_5(z) == 120*z-160*z^3+32*z^5
@end example

This method of generating the coefficients is of course far from optimal
for production purposes.

In order to show some more examples of what GiNaC can do we will now use
the @command{ginsh}, a simple GiNaC interactive shell that provides a
convenient window into GiNaC's capabilities.


@node What it can do for you, Installation, How to use it from within C++, A Tour of GiNaC
@c    node-name, next, previous, up
@section What it can do for you

@cindex @command{ginsh}
After invoking @command{ginsh} one can test and experiment with GiNaC's
features much like in other Computer Algebra Systems except that it does
not provide programming constructs like loops or conditionals.  For a
concise description of the @command{ginsh} syntax we refer to its
accompanied man page. Suffice to say that assignments and comparisons in
@command{ginsh} are written as they are in C, i.e. @code{=} assigns and
@code{==} compares.

It can manipulate arbitrary precision integers in a very fast way.
Rational numbers are automatically converted to fractions of coprime
integers:

@example
> x=3^150;
369988485035126972924700782451696644186473100389722973815184405301748249
> y=3^149;
123329495011708990974900260817232214728824366796574324605061468433916083
> x/y;
3
> y/x;
1/3
@end example

Exact numbers are always retained as exact numbers and only evaluated as
floating point numbers if requested.  For instance, with numeric
radicals is dealt pretty much as with symbols.  Products of sums of them
can be expanded:

@example
> expand((1+a^(1/5)-a^(2/5))^3);
1+3*a+3*a^(1/5)-5*a^(3/5)-a^(6/5)
> expand((1+3^(1/5)-3^(2/5))^3);
10-5*3^(3/5)
> evalf((1+3^(1/5)-3^(2/5))^3);
0.33408977534118624228
@end example

The function @code{evalf} that was used above converts any number in
GiNaC's expressions into floating point numbers.  This can be done to
arbitrary predefined accuracy:

@example
> evalf(1/7);
0.14285714285714285714
> Digits=150;
150
> evalf(1/7);
0.1428571428571428571428571428571428571428571428571428571428571428571428
5714285714285714285714285714285714285
@end example

Exact numbers other than rationals that can be manipulated in GiNaC
include predefined constants like Archimedes' @code{Pi}.  They can both
be used in symbolic manipulations (as an exact number) as well as in
numeric expressions (as an inexact number):

@example
> a=Pi^2+x;
x+Pi^2
> evalf(a);
9.869604401089358619+x
> x=2;
2
> evalf(a);
11.869604401089358619
@end example

Built-in functions evaluate immediately to exact numbers if
this is possible.  Conversions that can be safely performed are done
immediately; conversions that are not generally valid are not done:

@example
> cos(42*Pi);
1
> cos(acos(x));
x
> acos(cos(x));
acos(cos(x))
@end example

(Note that converting the last input to @code{x} would allow one to
conclude that @code{42*Pi} is equal to @code{0}.)

Linear equation systems can be solved along with basic linear
algebra manipulations over symbolic expressions.  In C++ GiNaC offers
a matrix class for this purpose but we can see what it can do using
@command{ginsh}'s bracket notation to type them in:

@example
> lsolve(a+x*y==z,x);
y^(-1)*(z-a);
> lsolve(@{3*x+5*y == 7, -2*x+10*y == -5@}, @{x, y@});
@{x==19/8,y==-1/40@}
> M = [ [1, 3], [-3, 2] ];
[[1,3],[-3,2]]
> determinant(M);
11
> charpoly(M,lambda);
lambda^2-3*lambda+11
> A = [ [1, 1], [2, -1] ];
[[1,1],[2,-1]]
> A+2*M;
[[1,1],[2,-1]]+2*[[1,3],[-3,2]]
> evalm(%);
[[3,7],[-4,3]]
> B = [ [0, 0, a], [b, 1, -b], [-1/a, 0, 0] ];
> evalm(B^(2^12345));
[[1,0,0],[0,1,0],[0,0,1]]
@end example

Multivariate polynomials and rational functions may be expanded,
collected and normalized (i.e. converted to a ratio of two coprime 
polynomials):

@example
> a = x^4 + 2*x^2*y^2 + 4*x^3*y + 12*x*y^3 - 3*y^4;
12*x*y^3+2*x^2*y^2+4*x^3*y-3*y^4+x^4
> b = x^2 + 4*x*y - y^2;
4*x*y-y^2+x^2
> expand(a*b);
8*x^5*y+17*x^4*y^2+43*x^2*y^4-24*x*y^5+16*x^3*y^3+3*y^6+x^6
> collect(a+b,x);
4*x^3*y-y^2-3*y^4+(12*y^3+4*y)*x+x^4+x^2*(1+2*y^2)
> collect(a+b,y);
12*x*y^3-3*y^4+(-1+2*x^2)*y^2+(4*x+4*x^3)*y+x^2+x^4
> normal(a/b);
3*y^2+x^2
@end example

You can differentiate functions and expand them as Taylor or Laurent
series in a very natural syntax (the second argument of @code{series} is
a relation defining the evaluation point, the third specifies the
order):

@cindex Zeta function
@example
> diff(tan(x),x);
tan(x)^2+1
> series(sin(x),x==0,4);
x-1/6*x^3+Order(x^4)
> series(1/tan(x),x==0,4);
x^(-1)-1/3*x+Order(x^2)
> series(tgamma(x),x==0,3);
x^(-1)-Euler+(1/12*Pi^2+1/2*Euler^2)*x+
(-1/3*zeta(3)-1/12*Pi^2*Euler-1/6*Euler^3)*x^2+Order(x^3)
> evalf(%);
x^(-1)-0.5772156649015328606+(0.9890559953279725555)*x
-(0.90747907608088628905)*x^2+Order(x^3)
> series(tgamma(2*sin(x)-2),x==Pi/2,6);
-(x-1/2*Pi)^(-2)+(-1/12*Pi^2-1/2*Euler^2-1/240)*(x-1/2*Pi)^2
-Euler-1/12+Order((x-1/2*Pi)^3)
@end example

Here we have made use of the @command{ginsh}-command @code{%} to pop the
previously evaluated element from @command{ginsh}'s internal stack.

If you ever wanted to convert units in C or C++ and found this is
cumbersome, here is the solution.  Symbolic types can always be used as
tags for different types of objects.  Converting from wrong units to the
metric system is now easy:

@example
> in=.0254*m;
0.0254*m
> lb=.45359237*kg;
0.45359237*kg
> 200*lb/in^2;
140613.91592783185568*kg*m^(-2)
@end example


@node Installation, Prerequisites, What it can do for you, Top
@c    node-name, next, previous, up
@chapter Installation

@cindex CLN
GiNaC's installation follows the spirit of most GNU software. It is
easily installed on your system by three steps: configuration, build,
installation.

@menu
* Prerequisites::                Packages upon which GiNaC depends.
* Configuration::                How to configure GiNaC.
* Building GiNaC::               How to compile GiNaC.
* Installing GiNaC::             How to install GiNaC on your system.
@end menu


@node Prerequisites, Configuration, Installation, Installation
@c    node-name, next, previous, up
@section Prerequisites

In order to install GiNaC on your system, some prerequisites need to be
met.  First of all, you need to have a C++-compiler adhering to the
ANSI-standard @cite{ISO/IEC 14882:1998(E)}.  We used GCC for development
so if you have a different compiler you are on your own.  For the
configuration to succeed you need a Posix compliant shell installed in
@file{/bin/sh}, GNU @command{bash} is fine.  Perl is needed by the built
process as well, since some of the source files are automatically
generated by Perl scripts.  Last but not least, Bruno Haible's library
CLN is extensively used and needs to be installed on your system.
Please get it either from @uref{ftp://ftp.santafe.edu/pub/gnu/}, from
@uref{ftp://ftpthep.physik.uni-mainz.de/pub/gnu/, GiNaC's FTP site} or
from @uref{ftp://ftp.ilog.fr/pub/Users/haible/gnu/, Bruno Haible's FTP
site} (it is covered by GPL) and install it prior to trying to install
GiNaC.  The configure script checks if it can find it and if it cannot
it will refuse to continue.


@node Configuration, Building GiNaC, Prerequisites, Installation
@c    node-name, next, previous, up
@section Configuration
@cindex configuration
@cindex Autoconf

To configure GiNaC means to prepare the source distribution for
building.  It is done via a shell script called @command{configure} that
is shipped with the sources and was originally generated by GNU
Autoconf.  Since a configure script generated by GNU Autoconf never
prompts, all customization must be done either via command line
parameters or environment variables.  It accepts a list of parameters,
the complete set of which can be listed by calling it with the
@option{--help} option.  The most important ones will be shortly
described in what follows:

@itemize @bullet

@item
@option{--disable-shared}: When given, this option switches off the
build of a shared library, i.e. a @file{.so} file.  This may be convenient
when developing because it considerably speeds up compilation.

@item
@option{--prefix=@var{PREFIX}}: The directory where the compiled library
and headers are installed. It defaults to @file{/usr/local} which means
that the library is installed in the directory @file{/usr/local/lib},
the header files in @file{/usr/local/include/ginac} and the documentation
(like this one) into @file{/usr/local/share/doc/GiNaC}.

@item
@option{--libdir=@var{LIBDIR}}: Use this option in case you want to have
the library installed in some other directory than
@file{@var{PREFIX}/lib/}.

@item
@option{--includedir=@var{INCLUDEDIR}}: Use this option in case you want
to have the header files installed in some other directory than
@file{@var{PREFIX}/include/ginac/}. For instance, if you specify
@option{--includedir=/usr/include} you will end up with the header files
sitting in the directory @file{/usr/include/ginac/}. Note that the
subdirectory @file{ginac} is enforced by this process in order to
keep the header files separated from others.  This avoids some
clashes and allows for an easier deinstallation of GiNaC. This ought
to be considered A Good Thing (tm).

@item
@option{--datadir=@var{DATADIR}}: This option may be given in case you
want to have the documentation installed in some other directory than
@file{@var{PREFIX}/share/doc/GiNaC/}.

@end itemize

In addition, you may specify some environment variables.  @env{CXX}
holds the path and the name of the C++ compiler in case you want to
override the default in your path.  (The @command{configure} script
searches your path for @command{c++}, @command{g++}, @command{gcc},
@command{CC}, @command{cxx} and @command{cc++} in that order.)  It may
be very useful to define some compiler flags with the @env{CXXFLAGS}
environment variable, like optimization, debugging information and
warning levels.  If omitted, it defaults to @option{-g
-O2}.@footnote{The @command{configure} script is itself generated from
the file @file{configure.ac}.  It is only distributed in packaged
releases of GiNaC.  If you got the naked sources, e.g. from CVS, you
must generate @command{configure} along with the various
@file{Makefile.in} by using the @command{autogen.sh} script.  This will
require a fair amount of support from your local toolchain, though.}

The whole process is illustrated in the following two
examples. (Substitute @command{setenv @var{VARIABLE} @var{value}} for
@command{export @var{VARIABLE}=@var{value}} if the Berkeley C shell is
your login shell.)

Here is a simple configuration for a site-wide GiNaC library assuming
everything is in default paths:

@example
$ export CXXFLAGS="-Wall -O2"
$ ./configure
@end example

And here is a configuration for a private static GiNaC library with
several components sitting in custom places (site-wide GCC and private
CLN).  The compiler is persuaded to be picky and full assertions and
debugging information are switched on:

@example
$ export CXX=/usr/local/gnu/bin/c++
$ export CPPFLAGS="$(CPPFLAGS) -I$(HOME)/include"
$ export CXXFLAGS="$(CXXFLAGS) -DDO_GINAC_ASSERT -ggdb -Wall -pedantic"
$ export LDFLAGS="$(LDFLAGS) -L$(HOME)/lib"
$ ./configure --disable-shared --prefix=$(HOME)
@end example


@node Building GiNaC, Installing GiNaC, Configuration, Installation
@c    node-name, next, previous, up
@section Building GiNaC
@cindex building GiNaC

After proper configuration you should just build the whole
library by typing
@example
$ make
@end example
at the command prompt and go for a cup of coffee.  The exact time it
takes to compile GiNaC depends not only on the speed of your machines
but also on other parameters, for instance what value for @env{CXXFLAGS}
you entered.  Optimization may be very time-consuming.

Just to make sure GiNaC works properly you may run a collection of
regression tests by typing

@example
$ make check
@end example

This will compile some sample programs, run them and check the output
for correctness.  The regression tests fall in three categories.  First,
the so called @emph{exams} are performed, simple tests where some
predefined input is evaluated (like a pupils' exam).  Second, the
@emph{checks} test the coherence of results among each other with
possible random input.  Third, some @emph{timings} are performed, which
benchmark some predefined problems with different sizes and display the
CPU time used in seconds.  Each individual test should return a message
@samp{passed}.  This is mostly intended to be a QA-check if something
was broken during development, not a sanity check of your system.  Some
of the tests in sections @emph{checks} and @emph{timings} may require
insane amounts of memory and CPU time.  Feel free to kill them if your
machine catches fire.  Another quite important intent is to allow people
to fiddle around with optimization.

Generally, the top-level Makefile runs recursively to the
subdirectories.  It is therefore safe to go into any subdirectory
(@code{doc/}, @code{ginsh/}, @dots{}) and simply type @code{make}
@var{target} there in case something went wrong.


@node Installing GiNaC, Basic Concepts, Building GiNaC, Installation
@c    node-name, next, previous, up
@section Installing GiNaC
@cindex installation

To install GiNaC on your system, simply type

@example
$ make install
@end example

As described in the section about configuration the files will be
installed in the following directories (the directories will be created
if they don't already exist):

@itemize @bullet

@item
@file{libginac.a} will go into @file{@var{PREFIX}/lib/} (or
@file{@var{LIBDIR}}) which defaults to @file{/usr/local/lib/}.
So will @file{libginac.so} unless the configure script was
given the option @option{--disable-shared}.  The proper symlinks
will be established as well.

@item
All the header files will be installed into @file{@var{PREFIX}/include/ginac/}
(or @file{@var{INCLUDEDIR}/ginac/}, if specified).

@item
All documentation (HTML and Postscript) will be stuffed into
@file{@var{PREFIX}/share/doc/GiNaC/} (or
@file{@var{DATADIR}/doc/GiNaC/}, if @var{DATADIR} was specified).

@end itemize

For the sake of completeness we will list some other useful make
targets: @command{make clean} deletes all files generated by
@command{make}, i.e. all the object files.  In addition @command{make
distclean} removes all files generated by the configuration and
@command{make maintainer-clean} goes one step further and deletes files
that may require special tools to rebuild (like the @command{libtool}
for instance).  Finally @command{make uninstall} removes the installed
library, header files and documentation@footnote{Uninstallation does not
work after you have called @command{make distclean} since the
@file{Makefile} is itself generated by the configuration from
@file{Makefile.in} and hence deleted by @command{make distclean}.  There
are two obvious ways out of this dilemma.  First, you can run the
configuration again with the same @var{PREFIX} thus creating a
@file{Makefile} with a working @samp{uninstall} target.  Second, you can
do it by hand since you now know where all the files went during
installation.}.


@node Basic Concepts, Expressions, Installing GiNaC, Top
@c    node-name, next, previous, up
@chapter Basic Concepts

This chapter will describe the different fundamental objects that can be
handled by GiNaC.  But before doing so, it is worthwhile introducing you
to the more commonly used class of expressions, representing a flexible
meta-class for storing all mathematical objects.

@menu
* Expressions::                  The fundamental GiNaC class.
* The Class Hierarchy::          Overview of GiNaC's classes.
* Error handling::               How the library reports errors.
* Symbols::                      Symbolic objects.
* Numbers::                      Numerical objects.
* Constants::                    Pre-defined constants.
* Fundamental containers::       The power, add and mul classes.
* Lists::                        Lists of expressions.
* Mathematical functions::       Mathematical functions.
* Relations::                    Equality, Inequality and all that.
* Matrices::                     Matrices.
* Indexed objects::              Handling indexed quantities.
* Non-commutative objects::      Algebras with non-commutative products.
@end menu


@node Expressions, The Class Hierarchy, Basic Concepts, Basic Concepts
@c    node-name, next, previous, up
@section Expressions
@cindex expression (class @code{ex})
@cindex @code{has()}

The most common class of objects a user deals with is the expression
@code{ex}, representing a mathematical object like a variable, number,
function, sum, product, etc@dots{}  Expressions may be put together to form
new expressions, passed as arguments to functions, and so on.  Here is a
little collection of valid expressions:

@example
ex MyEx1 = 5;                       // simple number
ex MyEx2 = x + 2*y;                 // polynomial in x and y
ex MyEx3 = (x + 1)/(x - 1);         // rational expression
ex MyEx4 = sin(x + 2*y) + 3*z + 41; // containing a function
ex MyEx5 = MyEx4 + 1;               // similar to above
@end example

Expressions are handles to other more fundamental objects, that often
contain other expressions thus creating a tree of expressions
(@xref{Internal Structures}, for particular examples).  Most methods on
@code{ex} therefore run top-down through such an expression tree.  For
example, the method @code{has()} scans recursively for occurrences of
something inside an expression.  Thus, if you have declared @code{MyEx4}
as in the example above @code{MyEx4.has(y)} will find @code{y} inside
the argument of @code{sin} and hence return @code{true}.

The next sections will outline the general picture of GiNaC's class
hierarchy and describe the classes of objects that are handled by
@code{ex}.


@node The Class Hierarchy, Error handling, Expressions, Basic Concepts
@c    node-name, next, previous, up
@section The Class Hierarchy

GiNaC's class hierarchy consists of several classes representing
mathematical objects, all of which (except for @code{ex} and some
helpers) are internally derived from one abstract base class called
@code{basic}.  You do not have to deal with objects of class
@code{basic}, instead you'll be dealing with symbols, numbers,
containers of expressions and so on.

@cindex container
@cindex atom
To get an idea about what kinds of symbolic composits may be built we
have a look at the most important classes in the class hierarchy and
some of the relations among the classes:

@image{classhierarchy}

The abstract classes shown here (the ones without drop-shadow) are of no
interest for the user.  They are used internally in order to avoid code
duplication if two or more classes derived from them share certain
features.  An example is @code{expairseq}, a container for a sequence of
pairs each consisting of one expression and a number (@code{numeric}).
What @emph{is} visible to the user are the derived classes @code{add}
and @code{mul}, representing sums and products.  @xref{Internal
Structures}, where these two classes are described in more detail.  The
following table shortly summarizes what kinds of mathematical objects
are stored in the different classes:

@cartouche
@multitable @columnfractions .22 .78
@item @code{symbol} @tab Algebraic symbols @math{a}, @math{x}, @math{y}@dots{}
@item @code{constant} @tab Constants like 
@tex
$\pi$
@end tex
@ifnottex
@math{Pi}
@end ifnottex
@item @code{numeric} @tab All kinds of numbers, @math{42}, @math{7/3*I}, @math{3.14159}@dots{}
@item @code{add} @tab Sums like @math{x+y} or @math{a-(2*b)+3}
@item @code{mul} @tab Products like @math{x*y} or @math{2*a^2*(x+y+z)/b}
@item @code{ncmul} @tab Products of non-commutative objects
@item @code{power} @tab Exponentials such as @math{x^2}, @math{a^b}, 
@tex
$\sqrt{2}$
@end tex
@ifnottex
@code{sqrt(}@math{2}@code{)}
@end ifnottex
@dots{}
@item @code{pseries} @tab Power Series, e.g. @math{x-1/6*x^3+1/120*x^5+O(x^7)}
@item @code{function} @tab A symbolic function like @math{sin(2*x)}
@item @code{lst} @tab Lists of expressions @{@math{x}, @math{2*y}, @math{3+z}@}
@item @code{matrix} @tab @math{m}x@math{n} matrices of expressions
@item @code{relational} @tab A relation like the identity @math{x}@code{==}@math{y}
@item @code{indexed} @tab Indexed object like @math{A_ij}
@item @code{tensor} @tab Special tensor like the delta and metric tensors
@item @code{idx} @tab Index of an indexed object
@item @code{varidx} @tab Index with variance
@item @code{spinidx} @tab Index with variance and dot (used in Weyl-van-der-Waerden spinor formalism)
@item @code{wildcard} @tab Wildcard for pattern matching
@end multitable
@end cartouche


@node Error handling, Symbols, The Class Hierarchy, Basic Concepts
@c    node-name, next, previous, up
@section Error handling
@cindex exceptions
@cindex @code{pole_error} (class)

GiNaC reports run-time errors by throwing C++ exceptions. All exceptions
generated by GiNaC are subclassed from the standard @code{exception} class
defined in the @file{<stdexcept>} header. In addition to the predefined
@code{logic_error}, @code{domain_error}, @code{out_of_range},
@code{invalid_argument}, @code{runtime_error}, @code{range_error} and
@code{overflow_error} types, GiNaC also defines a @code{pole_error}
exception that gets thrown when trying to evaluate a mathematical function
at a singularity.

The @code{pole_error} class has a member function

@example
int pole_error::degree(void) const;
@end example

that returns the order of the singularity (or 0 when the pole is
logarithmic or the order is undefined).

When using GiNaC it is useful to arrange for exceptions to be catched in
the main program even if you don't want to do any special error handling.
Otherwise whenever an error occurs in GiNaC, it will be delegated to the
default exception handler of your C++ compiler's run-time system which
usually only aborts the program without giving any information what went
wrong.

Here is an example for a @code{main()} function that catches and prints
exceptions generated by GiNaC:

@example
#include <iostream>
#include <stdexcept>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main(void)
@{
    try @{
        ...
        // code using GiNaC
        ...
    @} catch (exception &p) @{
        cerr << p.what() << endl;
        return 1;
    @}
    return 0;
@}
@end example


@node Symbols, Numbers, Error handling, Basic Concepts
@c    node-name, next, previous, up
@section Symbols
@cindex @code{symbol} (class)
@cindex hierarchy of classes

@cindex atom
Symbols are for symbolic manipulation what atoms are for chemistry.  You
can declare objects of class @code{symbol} as any other object simply by
saying @code{symbol x,y;}.  There is, however, a catch in here having to
do with the fact that C++ is a compiled language.  The information about
the symbol's name is thrown away by the compiler but at a later stage
you may want to print expressions holding your symbols.  In order to
avoid confusion GiNaC's symbols are able to know their own name.  This
is accomplished by declaring its name for output at construction time in
the fashion @code{symbol x("x");}.  If you declare a symbol using the
default constructor (i.e. without string argument) the system will deal
out a unique name.  That name may not be suitable for printing but for
internal routines when no output is desired it is often enough.  We'll
come across examples of such symbols later in this tutorial.

This implies that the strings passed to symbols at construction time may
not be used for comparing two of them.  It is perfectly legitimate to
write @code{symbol x("x"),y("x");} but it is likely to lead into
trouble.  Here, @code{x} and @code{y} are different symbols and
statements like @code{x-y} will not be simplified to zero although the
output @code{x-x} looks funny.  Such output may also occur when there
are two different symbols in two scopes, for instance when you call a
function that declares a symbol with a name already existent in a symbol
in the calling function.  Again, comparing them (using @code{operator==}
for instance) will always reveal their difference.  Watch out, please.

@cindex @code{subs()}
Although symbols can be assigned expressions for internal reasons, you
should not do it (and we are not going to tell you how it is done).  If
you want to replace a symbol with something else in an expression, you
can use the expression's @code{.subs()} method (@pxref{Substituting Expressions}).


@node Numbers, Constants, Symbols, Basic Concepts
@c    node-name, next, previous, up
@section Numbers
@cindex @code{numeric} (class)

@cindex GMP
@cindex CLN
@cindex rational
@cindex fraction
For storing numerical things, GiNaC uses Bruno Haible's library CLN.
The classes therein serve as foundation classes for GiNaC.  CLN stands
for Class Library for Numbers or alternatively for Common Lisp Numbers.
In order to find out more about CLN's internals the reader is refered to
the documentation of that library.  @inforef{Introduction, , cln}, for
more information. Suffice to say that it is by itself build on top of
another library, the GNU Multiple Precision library GMP, which is an
extremely fast library for arbitrary long integers and rationals as well
as arbitrary precision floating point numbers.  It is very commonly used
by several popular cryptographic applications.  CLN extends GMP by
several useful things: First, it introduces the complex number field
over either reals (i.e. floating point numbers with arbitrary precision)
or rationals.  Second, it automatically converts rationals to integers
if the denominator is unity and complex numbers to real numbers if the
imaginary part vanishes and also correctly treats algebraic functions.
Third it provides good implementations of state-of-the-art algorithms
for all trigonometric and hyperbolic functions as well as for
calculation of some useful constants.

The user can construct an object of class @code{numeric} in several
ways.  The following example shows the four most important constructors.
It uses construction from C-integer, construction of fractions from two
integers, construction from C-float and construction from a string:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    numeric two = 2;                      // exact integer 2
    numeric r(2,3);                       // exact fraction 2/3
    numeric e(2.71828);                   // floating point number
    numeric p = "3.14159265358979323846"; // constructor from string
    // Trott's constant in scientific notation:
    numeric trott("1.0841015122311136151E-2");
    
    std::cout << two*p << std::endl;  // floating point 6.283...
@}
@end example

It may be tempting to construct numbers writing @code{numeric r(3/2)}.
This would, however, call C's built-in operator @code{/} for integers
first and result in a numeric holding a plain integer 1.  @strong{Never
use the operator @code{/} on integers} unless you know exactly what you
are doing!  Use the constructor from two integers instead, as shown in
the example above.  Writing @code{numeric(1)/2} may look funny but works
also.

@cindex @code{Digits}
@cindex accuracy
We have seen now the distinction between exact numbers and floating
point numbers.  Clearly, the user should never have to worry about
dynamically created exact numbers, since their `exactness' always
determines how they ought to be handled, i.e. how `long' they are.  The
situation is different for floating point numbers.  Their accuracy is
controlled by one @emph{global} variable, called @code{Digits}.  (For
those readers who know about Maple: it behaves very much like Maple's
@code{Digits}).  All objects of class numeric that are constructed from
then on will be stored with a precision matching that number of decimal
digits:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

void foo()
@{
    numeric three(3.0), one(1.0);
    numeric x = one/three;

    cout << "in " << Digits << " digits:" << endl;
    cout << x << endl;
    cout << Pi.evalf() << endl;
@}

int main()
@{
    foo();
    Digits = 60;
    foo();
    return 0;
@}
@end example

The above example prints the following output to screen:

@example
in 17 digits:
0.33333333333333333334
3.1415926535897932385
in 60 digits:
0.33333333333333333333333333333333333333333333333333333333333333333334
3.1415926535897932384626433832795028841971693993751058209749445923078
@end example

@cindex rounding
Note that the last number is not necessarily rounded as you would
naively expect it to be rounded in the decimal system.  But note also,
that in both cases you got a couple of extra digits.  This is because
numbers are internally stored by CLN as chunks of binary digits in order
to match your machine's word size and to not waste precision.  Thus, on
architectures with differnt word size, the above output might even
differ with regard to actually computed digits.

It should be clear that objects of class @code{numeric} should be used
for constructing numbers or for doing arithmetic with them.  The objects
one deals with most of the time are the polymorphic expressions @code{ex}.

@subsection Tests on numbers

Once you have declared some numbers, assigned them to expressions and
done some arithmetic with them it is frequently desired to retrieve some
kind of information from them like asking whether that number is
integer, rational, real or complex.  For those cases GiNaC provides
several useful methods.  (Internally, they fall back to invocations of
certain CLN functions.)

As an example, let's construct some rational number, multiply it with
some multiple of its denominator and test what comes out:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

// some very important constants:
const numeric twentyone(21);
const numeric ten(10);
const numeric five(5);

int main()
@{
    numeric answer = twentyone;

    answer /= five;
    cout << answer.is_integer() << endl;  // false, it's 21/5
    answer *= ten;
    cout << answer.is_integer() << endl;  // true, it's 42 now!
@}
@end example

Note that the variable @code{answer} is constructed here as an integer
by @code{numeric}'s copy constructor but in an intermediate step it
holds a rational number represented as integer numerator and integer
denominator.  When multiplied by 10, the denominator becomes unity and
the result is automatically converted to a pure integer again.
Internally, the underlying CLN is responsible for this behavior and we
refer the reader to CLN's documentation.  Suffice to say that
the same behavior applies to complex numbers as well as return values of
certain functions.  Complex numbers are automatically converted to real
numbers if the imaginary part becomes zero.  The full set of tests that
can be applied is listed in the following table.

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Method} @tab @strong{Returns true if the object is@dots{}}
@item @code{.is_zero()}
@tab @dots{}equal to zero
@item @code{.is_positive()}
@tab @dots{}not complex and greater than 0
@item @code{.is_integer()}
@tab @dots{}a (non-complex) integer
@item @code{.is_pos_integer()}
@tab @dots{}an integer and greater than 0
@item @code{.is_nonneg_integer()}
@tab @dots{}an integer and greater equal 0
@item @code{.is_even()}
@tab @dots{}an even integer
@item @code{.is_odd()}
@tab @dots{}an odd integer
@item @code{.is_prime()}
@tab @dots{}a prime integer (probabilistic primality test)
@item @code{.is_rational()}
@tab @dots{}an exact rational number (integers are rational, too)
@item @code{.is_real()}
@tab @dots{}a real integer, rational or float (i.e. is not complex)
@item @code{.is_cinteger()}
@tab @dots{}a (complex) integer (such as @math{2-3*I})
@item @code{.is_crational()}
@tab @dots{}an exact (complex) rational number (such as @math{2/3+7/2*I})
@end multitable
@end cartouche


@node Constants, Fundamental containers, Numbers, Basic Concepts
@c    node-name, next, previous, up
@section Constants
@cindex @code{constant} (class)

@cindex @code{Pi}
@cindex @code{Catalan}
@cindex @code{Euler}
@cindex @code{evalf()}
Constants behave pretty much like symbols except that they return some
specific number when the method @code{.evalf()} is called.

The predefined known constants are:

@cartouche
@multitable @columnfractions .14 .30 .56
@item @strong{Name} @tab @strong{Common Name} @tab @strong{Numerical Value (to 35 digits)}
@item @code{Pi}
@tab Archimedes' constant
@tab 3.14159265358979323846264338327950288
@item @code{Catalan}
@tab Catalan's constant
@tab 0.91596559417721901505460351493238411
@item @code{Euler}
@tab Euler's (or Euler-Mascheroni) constant
@tab 0.57721566490153286060651209008240243
@end multitable
@end cartouche


@node Fundamental containers, Lists, Constants, Basic Concepts
@c    node-name, next, previous, up
@section Fundamental containers: the @code{power}, @code{add} and @code{mul} classes
@cindex polynomial
@cindex @code{add}
@cindex @code{mul}
@cindex @code{power}

Simple polynomial expressions are written down in GiNaC pretty much like
in other CAS or like expressions involving numerical variables in C.
The necessary operators @code{+}, @code{-}, @code{*} and @code{/} have
been overloaded to achieve this goal.  When you run the following
code snippet, the constructor for an object of type @code{mul} is
automatically called to hold the product of @code{a} and @code{b} and
then the constructor for an object of type @code{add} is called to hold
the sum of that @code{mul} object and the number one:

@example
    ...
    symbol a("a"), b("b");
    ex MyTerm = 1+a*b;
    ...
@end example

@cindex @code{pow()}
For exponentiation, you have already seen the somewhat clumsy (though C-ish)
statement @code{pow(x,2);} to represent @code{x} squared.  This direct
construction is necessary since we cannot safely overload the constructor
@code{^} in C++ to construct a @code{power} object.  If we did, it would
have several counterintuitive and undesired effects:

@itemize @bullet
@item
Due to C's operator precedence, @code{2*x^2} would be parsed as @code{(2*x)^2}.
@item
Due to the binding of the operator @code{^}, @code{x^a^b} would result in
@code{(x^a)^b}. This would be confusing since most (though not all) other CAS
interpret this as @code{x^(a^b)}.
@item
Also, expressions involving integer exponents are very frequently used,
which makes it even more dangerous to overload @code{^} since it is then
hard to distinguish between the semantics as exponentiation and the one
for exclusive or.  (It would be embarrassing to return @code{1} where one
has requested @code{2^3}.)
@end itemize

@cindex @command{ginsh}
All effects are contrary to mathematical notation and differ from the
way most other CAS handle exponentiation, therefore overloading @code{^}
is ruled out for GiNaC's C++ part.  The situation is different in
@command{ginsh}, there the exponentiation-@code{^} exists.  (Also note
that the other frequently used exponentiation operator @code{**} does
not exist at all in C++).

To be somewhat more precise, objects of the three classes described
here, are all containers for other expressions.  An object of class
@code{power} is best viewed as a container with two slots, one for the
basis, one for the exponent.  All valid GiNaC expressions can be
inserted.  However, basic transformations like simplifying
@code{pow(pow(x,2),3)} to @code{x^6} automatically are only performed
when this is mathematically possible.  If we replace the outer exponent
three in the example by some symbols @code{a}, the simplification is not
safe and will not be performed, since @code{a} might be @code{1/2} and
@code{x} negative.

Objects of type @code{add} and @code{mul} are containers with an
arbitrary number of slots for expressions to be inserted.  Again, simple
and safe simplifications are carried out like transforming
@code{3*x+4-x} to @code{2*x+4}.

The general rule is that when you construct such objects, GiNaC
automatically creates them in canonical form, which might differ from
the form you typed in your program.  This allows for rapid comparison of
expressions, since after all @code{a-a} is simply zero.  Note, that the
canonical form is not necessarily lexicographical ordering or in any way
easily guessable.  It is only guaranteed that constructing the same
expression twice, either implicitly or explicitly, results in the same
canonical form.


@node Lists, Mathematical functions, Fundamental containers, Basic Concepts
@c    node-name, next, previous, up
@section Lists of expressions
@cindex @code{lst} (class)
@cindex lists
@cindex @code{nops()}
@cindex @code{op()}
@cindex @code{append()}
@cindex @code{prepend()}
@cindex @code{remove_first()}
@cindex @code{remove_last()}

The GiNaC class @code{lst} serves for holding a @dfn{list} of arbitrary
expressions. These are sometimes used to supply a variable number of
arguments of the same type to GiNaC methods such as @code{subs()} and
@code{to_rational()}, so you should have a basic understanding about them.

Lists of up to 16 expressions can be directly constructed from single
expressions:

@example
@{
    symbol x("x"), y("y");
    lst l(x, 2, y, x+y);
    // now, l is a list holding the expressions 'x', '2', 'y', and 'x+y'
    // ...
@end example

Use the @code{nops()} method to determine the size (number of expressions) of
a list and the @code{op()} method to access individual elements:

@example
    // ...
    cout << l.nops() << endl;                   // prints '4'
    cout << l.op(2) << " " << l.op(0) << endl;  // prints 'y x'
    // ...
@end example

You can append or prepend an expression to a list with the @code{append()}
and @code{prepend()} methods:

@example
    // ...
    l.append(4*x);   // l is now @{x, 2, y, x+y, 4*x@}
    l.prepend(0);    // l is now @{0, x, 2, y, x+y, 4*x@}
    // ...
@end example

Finally you can remove the first or last element of a list with
@code{remove_first()} and @code{remove_last()}:

@example
    // ...
    l.remove_first();   // l is now @{x, 2, y, x+y, 4*x@}
    l.remove_last();    // l is now @{x, 2, y, x+y@}
@}
@end example


@node Mathematical functions, Relations, Lists, Basic Concepts
@c    node-name, next, previous, up
@section Mathematical functions
@cindex @code{function} (class)
@cindex trigonometric function
@cindex hyperbolic function

There are quite a number of useful functions hard-wired into GiNaC.  For
instance, all trigonometric and hyperbolic functions are implemented
(@xref{Built-in Functions}, for a complete list).

These functions (better called @emph{pseudofunctions}) are all objects
of class @code{function}.  They accept one or more expressions as
arguments and return one expression.  If the arguments are not
numerical, the evaluation of the function may be halted, as it does in
the next example, showing how a function returns itself twice and
finally an expression that may be really useful:

@cindex Gamma function
@cindex @code{subs()}
@example
    ...
    symbol x("x"), y("y");    
    ex foo = x+y/2;
    cout << tgamma(foo) << endl;
     // -> tgamma(x+(1/2)*y)
    ex bar = foo.subs(y==1);
    cout << tgamma(bar) << endl;
     // -> tgamma(x+1/2)
    ex foobar = bar.subs(x==7);
    cout << tgamma(foobar) << endl;
     // -> (135135/128)*Pi^(1/2)
    ...
@end example

Besides evaluation most of these functions allow differentiation, series
expansion and so on.  Read the next chapter in order to learn more about
this.

It must be noted that these pseudofunctions are created by inline
functions, where the argument list is templated.  This means that
whenever you call @code{GiNaC::sin(1)} it is equivalent to
@code{sin(ex(1))} and will therefore not result in a floating point
number.  Unless of course the function prototype is explicitly
overridden -- which is the case for arguments of type @code{numeric}
(not wrapped inside an @code{ex}).  Hence, in order to obtain a floating
point number of class @code{numeric} you should call
@code{sin(numeric(1))}.  This is almost the same as calling
@code{sin(1).evalf()} except that the latter will return a numeric
wrapped inside an @code{ex}.


@node Relations, Matrices, Mathematical functions, Basic Concepts
@c    node-name, next, previous, up
@section Relations
@cindex @code{relational} (class)

Sometimes, a relation holding between two expressions must be stored
somehow.  The class @code{relational} is a convenient container for such
purposes.  A relation is by definition a container for two @code{ex} and
a relation between them that signals equality, inequality and so on.
They are created by simply using the C++ operators @code{==}, @code{!=},
@code{<}, @code{<=}, @code{>} and @code{>=} between two expressions.

@xref{Mathematical functions}, for examples where various applications
of the @code{.subs()} method show how objects of class relational are
used as arguments.  There they provide an intuitive syntax for
substitutions.  They are also used as arguments to the @code{ex::series}
method, where the left hand side of the relation specifies the variable
to expand in and the right hand side the expansion point.  They can also
be used for creating systems of equations that are to be solved for
unknown variables.  But the most common usage of objects of this class
is rather inconspicuous in statements of the form @code{if
(expand(pow(a+b,2))==a*a+2*a*b+b*b) @{...@}}.  Here, an implicit
conversion from @code{relational} to @code{bool} takes place.  Note,
however, that @code{==} here does not perform any simplifications, hence
@code{expand()} must be called explicitly.


@node Matrices, Indexed objects, Relations, Basic Concepts
@c    node-name, next, previous, up
@section Matrices
@cindex @code{matrix} (class)

A @dfn{matrix} is a two-dimensional array of expressions. The elements of a
matrix with @math{m} rows and @math{n} columns are accessed with two
@code{unsigned} indices, the first one in the range 0@dots{}@math{m-1}, the
second one in the range 0@dots{}@math{n-1}.

There are a couple of ways to construct matrices, with or without preset
elements:

@example
matrix::matrix(unsigned r, unsigned c);
matrix::matrix(unsigned r, unsigned c, const lst & l);
ex lst_to_matrix(const lst & l);
ex diag_matrix(const lst & l);
@end example

The first two functions are @code{matrix} constructors which create a matrix
with @samp{r} rows and @samp{c} columns. The matrix elements can be
initialized from a (flat) list of expressions @samp{l}. Otherwise they are
all set to zero. The @code{lst_to_matrix()} function constructs a matrix
from a list of lists, each list representing a matrix row. Finally,
@code{diag_matrix()} constructs a diagonal matrix given the list of diagonal
elements. Note that the last two functions return expressions, not matrix
objects.

Matrix elements can be accessed and set using the parenthesis (function call)
operator:

@example
const ex & matrix::operator()(unsigned r, unsigned c) const;
ex & matrix::operator()(unsigned r, unsigned c);
@end example

It is also possible to access the matrix elements in a linear fashion with
the @code{op()} method. But C++-style subscripting with square brackets
@samp{[]} is not available.

Here are a couple of examples that all construct the same 2x2 diagonal
matrix:

@example
@{
    symbol a("a"), b("b");
    ex e;

    matrix M(2, 2);
    M(0, 0) = a;
    M(1, 1) = b;
    e = M;

    e = matrix(2, 2, lst(a, 0, 0, b));

    e = lst_to_matrix(lst(lst(a, 0), lst(0, b)));

    e = diag_matrix(lst(a, b));

    cout << e << endl;
     // -> [[a,0],[0,b]]
@}
@end example

@cindex @code{transpose()}
@cindex @code{inverse()}
There are three ways to do arithmetic with matrices. The first (and most
efficient one) is to use the methods provided by the @code{matrix} class:

@example
matrix matrix::add(const matrix & other) const;
matrix matrix::sub(const matrix & other) const;
matrix matrix::mul(const matrix & other) const;
matrix matrix::mul_scalar(const ex & other) const;
matrix matrix::pow(const ex & expn) const;
matrix matrix::transpose(void) const;
matrix matrix::inverse(void) const;
@end example

All of these methods return the result as a new matrix object. Here is an
example that calculates @math{A*B-2*C} for three matrices @math{A}, @math{B}
and @math{C}:

@example
@{
    matrix A(2, 2, lst(1, 2, 3, 4));
    matrix B(2, 2, lst(-1, 0, 2, 1));
    matrix C(2, 2, lst(8, 4, 2, 1));

    matrix result = A.mul(B).sub(C.mul_scalar(2));
    cout << result << endl;
     // -> [[-13,-6],[1,2]]
    ...
@}
@end example

@cindex @code{evalm()}
The second (and probably the most natural) way is to construct an expression
containing matrices with the usual arithmetic operators and @code{pow()}.
For efficiency reasons, expressions with sums, products and powers of
matrices are not automatically evaluated in GiNaC. You have to call the
method

@example
ex ex::evalm() const;
@end example

to obtain the result:

@example
@{
    ...
    ex e = A*B - 2*C;
    cout << e << endl;
     // -> [[1,2],[3,4]]*[[-1,0],[2,1]]-2*[[8,4],[2,1]]
    cout << e.evalm() << endl;
     // -> [[-13,-6],[1,2]]
    ...
@}
@end example

The non-commutativity of the product @code{A*B} in this example is
automatically recognized by GiNaC. There is no need to use a special
operator here. @xref{Non-commutative objects}, for more information about
dealing with non-commutative expressions.

Finally, you can work with indexed matrices and call @code{simplify_indexed()}
to perform the arithmetic:

@example
@{
    ...
    idx i(symbol("i"), 2), j(symbol("j"), 2), k(symbol("k"), 2);
    e = indexed(A, i, k) * indexed(B, k, j) - 2 * indexed(C, i, j);
    cout << e << endl;
     // -> -2*[[8,4],[2,1]].i.j+[[-1,0],[2,1]].k.j*[[1,2],[3,4]].i.k
    cout << e.simplify_indexed() << endl;
     // -> [[-13,-6],[1,2]].i.j
@}
@end example

Using indices is most useful when working with rectangular matrices and
one-dimensional vectors because you don't have to worry about having to
transpose matrices before multiplying them. @xref{Indexed objects}, for
more information about using matrices with indices, and about indices in
general.

The @code{matrix} class provides a couple of additional methods for
computing determinants, traces, and characteristic polynomials:

@example
ex matrix::determinant(unsigned algo = determinant_algo::automatic) const;
ex matrix::trace(void) const;
ex matrix::charpoly(const symbol & lambda) const;
@end example

The @samp{algo} argument of @code{determinant()} allows to select between
different algorithms for calculating the determinant. The possible values
are defined in the @file{flags.h} header file. By default, GiNaC uses a
heuristic to automatically select an algorithm that is likely to give the
result most quickly.


@node Indexed objects, Non-commutative objects, Matrices, Basic Concepts
@c    node-name, next, previous, up
@section Indexed objects

GiNaC allows you to handle expressions containing general indexed objects in
arbitrary spaces. It is also able to canonicalize and simplify such
expressions and perform symbolic dummy index summations. There are a number
of predefined indexed objects provided, like delta and metric tensors.

There are few restrictions placed on indexed objects and their indices and
it is easy to construct nonsense expressions, but our intention is to
provide a general framework that allows you to implement algorithms with
indexed quantities, getting in the way as little as possible.

@cindex @code{idx} (class)
@cindex @code{indexed} (class)
@subsection Indexed quantities and their indices

Indexed expressions in GiNaC are constructed of two special types of objects,
@dfn{index objects} and @dfn{indexed objects}.

@itemize @bullet

@cindex contravariant
@cindex covariant
@cindex variance
@item Index objects are of class @code{idx} or a subclass. Every index has
a @dfn{value} and a @dfn{dimension} (which is the dimension of the space
the index lives in) which can both be arbitrary expressions but are usually
a number or a simple symbol. In addition, indices of class @code{varidx} have
a @dfn{variance} (they can be co- or contravariant), and indices of class
@code{spinidx} have a variance and can be @dfn{dotted} or @dfn{undotted}.

@item Indexed objects are of class @code{indexed} or a subclass. They
contain a @dfn{base expression} (which is the expression being indexed), and
one or more indices.

@end itemize

@strong{Note:} when printing expressions, covariant indices and indices
without variance are denoted @samp{.i} while contravariant indices are
denoted @samp{~i}. Dotted indices have a @samp{*} in front of the index
value. In the following, we are going to use that notation in the text so
instead of @math{A^i_jk} we will write @samp{A~i.j.k}. Index dimensions are
not visible in the output.

A simple example shall illustrate the concepts:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol i_sym("i"), j_sym("j");
    idx i(i_sym, 3), j(j_sym, 3);

    symbol A("A");
    cout << indexed(A, i, j) << endl;
     // -> A.i.j
    ...
@end example

The @code{idx} constructor takes two arguments, the index value and the
index dimension. First we define two index objects, @code{i} and @code{j},
both with the numeric dimension 3. The value of the index @code{i} is the
symbol @code{i_sym} (which prints as @samp{i}) and the value of the index
@code{j} is the symbol @code{j_sym} (which prints as @samp{j}). Next we
construct an expression containing one indexed object, @samp{A.i.j}. It has
the symbol @code{A} as its base expression and the two indices @code{i} and
@code{j}.

Note the difference between the indices @code{i} and @code{j} which are of
class @code{idx}, and the index values which are the symbols @code{i_sym}
and @code{j_sym}. The indices of indexed objects cannot directly be symbols
or numbers but must be index objects. For example, the following is not
correct and will raise an exception:

@example
symbol i("i"), j("j");
e = indexed(A, i, j); // ERROR: indices must be of type idx
@end example

You can have multiple indexed objects in an expression, index values can
be numeric, and index dimensions symbolic:

@example
    ...
    symbol B("B"), dim("dim");
    cout << 4 * indexed(A, i)
          + indexed(B, idx(j_sym, 4), idx(2, 3), idx(i_sym, dim)) << endl;
     // -> B.j.2.i+4*A.i
    ...
@end example

@code{B} has a 4-dimensional symbolic index @samp{k}, a 3-dimensional numeric
index of value 2, and a symbolic index @samp{i} with the symbolic dimension
@samp{dim}. Note that GiNaC doesn't automatically notify you that the free
indices of @samp{A} and @samp{B} in the sum don't match (you have to call
@code{simplify_indexed()} for that, see below).

In fact, base expressions, index values and index dimensions can be
arbitrary expressions:

@example
    ...
    cout << indexed(A+B, idx(2*i_sym+1, dim/2)) << endl;
     // -> (B+A).(1+2*i)
    ...
@end example

It's also possible to construct nonsense like @samp{Pi.sin(x)}. You will not
get an error message from this but you will probably not be able to do
anything useful with it.

@cindex @code{get_value()}
@cindex @code{get_dimension()}
The methods

@example
ex idx::get_value(void);
ex idx::get_dimension(void);
@end example

return the value and dimension of an @code{idx} object. If you have an index
in an expression, such as returned by calling @code{.op()} on an indexed
object, you can get a reference to the @code{idx} object with the function
@code{ex_to<idx>()} on the expression.

There are also the methods

@example
bool idx::is_numeric(void);
bool idx::is_symbolic(void);
bool idx::is_dim_numeric(void);
bool idx::is_dim_symbolic(void);
@end example

for checking whether the value and dimension are numeric or symbolic
(non-numeric). Using the @code{info()} method of an index (see @ref{Information
About Expressions}) returns information about the index value.

@cindex @code{varidx} (class)
If you need co- and contravariant indices, use the @code{varidx} class:

@example
    ...
    symbol mu_sym("mu"), nu_sym("nu");
    varidx mu(mu_sym, 4), nu(nu_sym, 4); // default is contravariant ~mu, ~nu
    varidx mu_co(mu_sym, 4, true);       // covariant index .mu

    cout << indexed(A, mu, nu) << endl;
     // -> A~mu~nu
    cout << indexed(A, mu_co, nu) << endl;
     // -> A.mu~nu
    cout << indexed(A, mu.toggle_variance(), nu) << endl;
     // -> A.mu~nu
    ...
@end example

A @code{varidx} is an @code{idx} with an additional flag that marks it as
co- or contravariant. The default is a contravariant (upper) index, but
this can be overridden by supplying a third argument to the @code{varidx}
constructor. The two methods

@example
bool varidx::is_covariant(void);
bool varidx::is_contravariant(void);
@end example

allow you to check the variance of a @code{varidx} object (use @code{ex_to<varidx>()}
to get the object reference from an expression). There's also the very useful
method

@example
ex varidx::toggle_variance(void);
@end example

which makes a new index with the same value and dimension but the opposite
variance. By using it you only have to define the index once.

@cindex @code{spinidx} (class)
The @code{spinidx} class provides dotted and undotted variant indices, as
used in the Weyl-van-der-Waerden spinor formalism:

@example
    ...
    symbol K("K"), C_sym("C"), D_sym("D");
    spinidx C(C_sym, 2), D(D_sym);          // default is 2-dimensional,
                                            // contravariant, undotted
    spinidx C_co(C_sym, 2, true);           // covariant index
    spinidx D_dot(D_sym, 2, false, true);   // contravariant, dotted
    spinidx D_co_dot(D_sym, 2, true, true); // covariant, dotted

    cout << indexed(K, C, D) << endl;
     // -> K~C~D
    cout << indexed(K, C_co, D_dot) << endl;
     // -> K.C~*D
    cout << indexed(K, D_co_dot, D) << endl;
     // -> K.*D~D
    ...
@end example

A @code{spinidx} is a @code{varidx} with an additional flag that marks it as
dotted or undotted. The default is undotted but this can be overridden by
supplying a fourth argument to the @code{spinidx} constructor. The two
methods

@example
bool spinidx::is_dotted(void);
bool spinidx::is_undotted(void);
@end example

allow you to check whether or not a @code{spinidx} object is dotted (use
@code{ex_to<spinidx>()} to get the object reference from an expression).
Finally, the two methods

@example
ex spinidx::toggle_dot(void);
ex spinidx::toggle_variance_dot(void);
@end example

create a new index with the same value and dimension but opposite dottedness
and the same or opposite variance.

@subsection Substituting indices

@cindex @code{subs()}
Sometimes you will want to substitute one symbolic index with another
symbolic or numeric index, for example when calculating one specific element
of a tensor expression. This is done with the @code{.subs()} method, as it
is done for symbols (see @ref{Substituting Expressions}).

You have two possibilities here. You can either substitute the whole index
by another index or expression:

@example
    ...
    ex e = indexed(A, mu_co);
    cout << e << " becomes " << e.subs(mu_co == nu) << endl;
     // -> A.mu becomes A~nu
    cout << e << " becomes " << e.subs(mu_co == varidx(0, 4)) << endl;
     // -> A.mu becomes A~0
    cout << e << " becomes " << e.subs(mu_co == 0) << endl;
     // -> A.mu becomes A.0
    ...
@end example

The third example shows that trying to replace an index with something that
is not an index will substitute the index value instead.

Alternatively, you can substitute the @emph{symbol} of a symbolic index by
another expression:

@example
    ...
    ex e = indexed(A, mu_co);
    cout << e << " becomes " << e.subs(mu_sym == nu_sym) << endl;
     // -> A.mu becomes A.nu
    cout << e << " becomes " << e.subs(mu_sym == 0) << endl;
     // -> A.mu becomes A.0
    ...
@end example

As you see, with the second method only the value of the index will get
substituted. Its other properties, including its dimension, remain unchanged.
If you want to change the dimension of an index you have to substitute the
whole index by another one with the new dimension.

Finally, substituting the base expression of an indexed object works as
expected:

@example
    ...
    ex e = indexed(A, mu_co);
    cout << e << " becomes " << e.subs(A == A+B) << endl;
     // -> A.mu becomes (B+A).mu
    ...
@end example

@subsection Symmetries
@cindex @code{symmetry} (class)
@cindex @code{sy_none()}
@cindex @code{sy_symm()}
@cindex @code{sy_anti()}
@cindex @code{sy_cycl()}

Indexed objects can have certain symmetry properties with respect to their
indices. Symmetries are specified as a tree of objects of class @code{symmetry}
that is constructed with the helper functions

@example
symmetry sy_none(...);
symmetry sy_symm(...);
symmetry sy_anti(...);
symmetry sy_cycl(...);
@end example

@code{sy_none()} stands for no symmetry, @code{sy_symm()} and @code{sy_anti()}
specify fully symmetric or antisymmetric, respectively, and @code{sy_cycl()}
represents a cyclic symmetry. Each of these functions accepts up to four
arguments which can be either symmetry objects themselves or unsigned integer
numbers that represent an index position (counting from 0). A symmetry
specification that consists of only a single @code{sy_symm()}, @code{sy_anti()}
or @code{sy_cycl()} with no arguments specifies the respective symmetry for
all indices.

Here are some examples of symmetry definitions:

@example
    ...
    // No symmetry:
    e = indexed(A, i, j);
    e = indexed(A, sy_none(), i, j);     // equivalent
    e = indexed(A, sy_none(0, 1), i, j); // equivalent

    // Symmetric in all three indices:
    e = indexed(A, sy_symm(), i, j, k);
    e = indexed(A, sy_symm(0, 1, 2), i, j, k); // equivalent
    e = indexed(A, sy_symm(2, 0, 1), i, j, k); // same symmetry, but yields a
                                               // different canonical order

    // Symmetric in the first two indices only:
    e = indexed(A, sy_symm(0, 1), i, j, k);
    e = indexed(A, sy_none(sy_symm(0, 1), 2), i, j, k); // equivalent

    // Antisymmetric in the first and last index only (index ranges need not
    // be contiguous):
    e = indexed(A, sy_anti(0, 2), i, j, k);
    e = indexed(A, sy_none(sy_anti(0, 2), 1), i, j, k); // equivalent

    // An example of a mixed symmetry: antisymmetric in the first two and
    // last two indices, symmetric when swapping the first and last index
    // pairs (like the Riemann curvature tensor):
    e = indexed(A, sy_symm(sy_anti(0, 1), sy_anti(2, 3)), i, j, k, l);

    // Cyclic symmetry in all three indices:
    e = indexed(A, sy_cycl(), i, j, k);
    e = indexed(A, sy_cycl(0, 1, 2), i, j, k); // equivalent

    // The following examples are invalid constructions that will throw
    // an exception at run time.

    // An index may not appear multiple times:
    e = indexed(A, sy_symm(0, 0, 1), i, j, k); // ERROR
    e = indexed(A, sy_none(sy_symm(0, 1), sy_anti(0, 2)), i, j, k); // ERROR

    // Every child of sy_symm(), sy_anti() and sy_cycl() must refer to the
    // same number of indices:
    e = indexed(A, sy_symm(sy_anti(0, 1), 2), i, j, k); // ERROR

    // And of course, you cannot specify indices which are not there:
    e = indexed(A, sy_symm(0, 1, 2, 3), i, j, k); // ERROR
    ...
@end example

If you need to specify more than four indices, you have to use the
@code{.add()} method of the @code{symmetry} class. For example, to specify
full symmetry in the first six indices you would write
@code{sy_symm(0, 1, 2, 3).add(4).add(5)}.

If an indexed object has a symmetry, GiNaC will automatically bring the
indices into a canonical order which allows for some immediate simplifications:

@example
    ...
    cout << indexed(A, sy_symm(), i, j)
          + indexed(A, sy_symm(), j, i) << endl;
     // -> 2*A.j.i
    cout << indexed(B, sy_anti(), i, j)
          + indexed(B, sy_anti(), j, i) << endl;
     // -> -B.j.i
    cout << indexed(B, sy_anti(), i, j, k)
          + indexed(B, sy_anti(), j, i, k) << endl;
     // -> 0
    ...
@end example

@cindex @code{get_free_indices()}
@cindex Dummy index
@subsection Dummy indices

GiNaC treats certain symbolic index pairs as @dfn{dummy indices} meaning
that a summation over the index range is implied. Symbolic indices which are
not dummy indices are called @dfn{free indices}. Numeric indices are neither
dummy nor free indices.

To be recognized as a dummy index pair, the two indices must be of the same
class and dimension and their value must be the same single symbol (an index
like @samp{2*n+1} is never a dummy index). If the indices are of class
@code{varidx} they must also be of opposite variance; if they are of class
@code{spinidx} they must be both dotted or both undotted.

The method @code{.get_free_indices()} returns a vector containing the free
indices of an expression. It also checks that the free indices of the terms
of a sum are consistent:

@example
@{
    symbol A("A"), B("B"), C("C");

    symbol i_sym("i"), j_sym("j"), k_sym("k"), l_sym("l");
    idx i(i_sym, 3), j(j_sym, 3), k(k_sym, 3), l(l_sym, 3);

    ex e = indexed(A, i, j) * indexed(B, j, k) + indexed(C, k, l, i, l);
    cout << exprseq(e.get_free_indices()) << endl;
     // -> (.i,.k)
     // 'j' and 'l' are dummy indices

    symbol mu_sym("mu"), nu_sym("nu"), rho_sym("rho"), sigma_sym("sigma");
    varidx mu(mu_sym, 4), nu(nu_sym, 4), rho(rho_sym, 4), sigma(sigma_sym, 4);

    e = indexed(A, mu, nu) * indexed(B, nu.toggle_variance(), rho)
      + indexed(C, mu, sigma, rho, sigma.toggle_variance());
    cout << exprseq(e.get_free_indices()) << endl;
     // -> (~mu,~rho)
     // 'nu' is a dummy index, but 'sigma' is not

    e = indexed(A, mu, mu);
    cout << exprseq(e.get_free_indices()) << endl;
     // -> (~mu)
     // 'mu' is not a dummy index because it appears twice with the same
     // variance

    e = indexed(A, mu, nu) + 42;
    cout << exprseq(e.get_free_indices()) << endl; // ERROR
     // this will throw an exception:
     // "add::get_free_indices: inconsistent indices in sum"
@}
@end example

@cindex @code{simplify_indexed()}
@subsection Simplifying indexed expressions

In addition to the few automatic simplifications that GiNaC performs on
indexed expressions (such as re-ordering the indices of symmetric tensors
and calculating traces and convolutions of matrices and predefined tensors)
there is the method

@example
ex ex::simplify_indexed(void);
ex ex::simplify_indexed(const scalar_products & sp);
@end example

that performs some more expensive operations:

@itemize
@item it checks the consistency of free indices in sums in the same way
  @code{get_free_indices()} does
@item it tries to give dummy indices that appear in different terms of a sum
  the same name to allow simplifications like @math{a_i*b_i-a_j*b_j=0}
@item it (symbolically) calculates all possible dummy index summations/contractions
  with the predefined tensors (this will be explained in more detail in the
  next section)
@item it detects contractions that vanish for symmetry reasons, for example
  the contraction of a symmetric and a totally antisymmetric tensor
@item as a special case of dummy index summation, it can replace scalar products
  of two tensors with a user-defined value
@end itemize

The last point is done with the help of the @code{scalar_products} class
which is used to store scalar products with known values (this is not an
arithmetic class, you just pass it to @code{simplify_indexed()}):

@example
@{
    symbol A("A"), B("B"), C("C"), i_sym("i");
    idx i(i_sym, 3);

    scalar_products sp;
    sp.add(A, B, 0); // A and B are orthogonal
    sp.add(A, C, 0); // A and C are orthogonal
    sp.add(A, A, 4); // A^2 = 4 (A has length 2)

    e = indexed(A + B, i) * indexed(A + C, i);
    cout << e << endl;
     // -> (B+A).i*(A+C).i

    cout << e.expand(expand_options::expand_indexed).simplify_indexed(sp)
         << endl;
     // -> 4+C.i*B.i
@}
@end example

The @code{scalar_products} object @code{sp} acts as a storage for the
scalar products added to it with the @code{.add()} method. This method
takes three arguments: the two expressions of which the scalar product is
taken, and the expression to replace it with. After @code{sp.add(A, B, 0)},
@code{simplify_indexed()} will replace all scalar products of indexed
objects that have the symbols @code{A} and @code{B} as base expressions
with the single value 0. The number, type and dimension of the indices
don't matter; @samp{A~mu~nu*B.mu.nu} would also be replaced by 0.

@cindex @code{expand()}
The example above also illustrates a feature of the @code{expand()} method:
if passed the @code{expand_indexed} option it will distribute indices
over sums, so @samp{(A+B).i} becomes @samp{A.i+B.i}.

@cindex @code{tensor} (class)
@subsection Predefined tensors

Some frequently used special tensors such as the delta, epsilon and metric
tensors are predefined in GiNaC. They have special properties when
contracted with other tensor expressions and some of them have constant
matrix representations (they will evaluate to a number when numeric
indices are specified).

@cindex @code{delta_tensor()}
@subsubsection Delta tensor

The delta tensor takes two indices, is symmetric and has the matrix
representation @code{diag(1, 1, 1, ...)}. It is constructed by the function
@code{delta_tensor()}:

@example
@{
    symbol A("A"), B("B");

    idx i(symbol("i"), 3), j(symbol("j"), 3),
        k(symbol("k"), 3), l(symbol("l"), 3);

    ex e = indexed(A, i, j) * indexed(B, k, l)
         * delta_tensor(i, k) * delta_tensor(j, l) << endl;
    cout << e.simplify_indexed() << endl;
     // -> B.i.j*A.i.j

    cout << delta_tensor(i, i) << endl;
     // -> 3
@}
@end example

@cindex @code{metric_tensor()}
@subsubsection General metric tensor

The function @code{metric_tensor()} creates a general symmetric metric
tensor with two indices that can be used to raise/lower tensor indices. The
metric tensor is denoted as @samp{g} in the output and if its indices are of
mixed variance it is automatically replaced by a delta tensor:

@example
@{
    symbol A("A");

    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4);

    ex e = metric_tensor(mu, nu) * indexed(A, nu.toggle_variance(), rho);
    cout << e.simplify_indexed() << endl;
     // -> A~mu~rho

    e = delta_tensor(mu, nu.toggle_variance()) * metric_tensor(nu, rho);
    cout << e.simplify_indexed() << endl;
     // -> g~mu~rho

    e = metric_tensor(mu.toggle_variance(), nu.toggle_variance())
      * metric_tensor(nu, rho);
    cout << e.simplify_indexed() << endl;
     // -> delta.mu~rho

    e = metric_tensor(nu.toggle_variance(), rho.toggle_variance())
      * metric_tensor(mu, nu) * (delta_tensor(mu.toggle_variance(), rho)
        + indexed(A, mu.toggle_variance(), rho));
    cout << e.simplify_indexed() << endl;
     // -> 4+A.rho~rho
@}
@end example

@cindex @code{lorentz_g()}
@subsubsection Minkowski metric tensor

The Minkowski metric tensor is a special metric tensor with a constant
matrix representation which is either @code{diag(1, -1, -1, ...)} (negative
signature, the default) or @code{diag(-1, 1, 1, ...)} (positive signature).
It is created with the function @code{lorentz_g()} (although it is output as
@samp{eta}):

@example
@{
    varidx mu(symbol("mu"), 4);

    e = delta_tensor(varidx(0, 4), mu.toggle_variance())
      * lorentz_g(mu, varidx(0, 4));       // negative signature
    cout << e.simplify_indexed() << endl;
     // -> 1

    e = delta_tensor(varidx(0, 4), mu.toggle_variance())
      * lorentz_g(mu, varidx(0, 4), true); // positive signature
    cout << e.simplify_indexed() << endl;
     // -> -1
@}
@end example

@cindex @code{spinor_metric()}
@subsubsection Spinor metric tensor

The function @code{spinor_metric()} creates an antisymmetric tensor with
two indices that is used to raise/lower indices of 2-component spinors.
It is output as @samp{eps}:

@example
@{
    symbol psi("psi");

    spinidx A(symbol("A")), B(symbol("B")), C(symbol("C"));
    ex A_co = A.toggle_variance(), B_co = B.toggle_variance();

    e = spinor_metric(A, B) * indexed(psi, B_co);
    cout << e.simplify_indexed() << endl;
     // -> psi~A

    e = spinor_metric(A, B) * indexed(psi, A_co);
    cout << e.simplify_indexed() << endl;
     // -> -psi~B

    e = spinor_metric(A_co, B_co) * indexed(psi, B);
    cout << e.simplify_indexed() << endl;
     // -> -psi.A

    e = spinor_metric(A_co, B_co) * indexed(psi, A);
    cout << e.simplify_indexed() << endl;
     // -> psi.B

    e = spinor_metric(A_co, B_co) * spinor_metric(A, B);
    cout << e.simplify_indexed() << endl;
     // -> 2

    e = spinor_metric(A_co, B_co) * spinor_metric(B, C);
    cout << e.simplify_indexed() << endl;
     // -> -delta.A~C
@}
@end example

The matrix representation of the spinor metric is @code{[[0, 1], [-1, 0]]}.

@cindex @code{epsilon_tensor()}
@cindex @code{lorentz_eps()}
@subsubsection Epsilon tensor

The epsilon tensor is totally antisymmetric, its number of indices is equal
to the dimension of the index space (the indices must all be of the same
numeric dimension), and @samp{eps.1.2.3...} (resp. @samp{eps~0~1~2...}) is
defined to be 1. Its behavior with indices that have a variance also
depends on the signature of the metric. Epsilon tensors are output as
@samp{eps}.

There are three functions defined to create epsilon tensors in 2, 3 and 4
dimensions:

@example
ex epsilon_tensor(const ex & i1, const ex & i2);
ex epsilon_tensor(const ex & i1, const ex & i2, const ex & i3);
ex lorentz_eps(const ex & i1, const ex & i2, const ex & i3, const ex & i4, bool pos_sig = false);
@end example

The first two functions create an epsilon tensor in 2 or 3 Euclidean
dimensions, the last function creates an epsilon tensor in a 4-dimensional
Minkowski space (the last @code{bool} argument specifies whether the metric
has negative or positive signature, as in the case of the Minkowski metric
tensor):

@example
@{
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4),
           sig(symbol("sig"), 4), lam(symbol("lam"), 4), bet(symbol("bet"), 4);
    e = lorentz_eps(mu, nu, rho, sig) *
        lorentz_eps(mu.toggle_variance(), nu.toggle_variance(), lam, bet);
    cout << simplify_indexed(e) << endl;
     // -> 2*eta~bet~rho*eta~sig~lam-2*eta~sig~bet*eta~rho~lam

    idx i(symbol("i"), 3), j(symbol("j"), 3), k(symbol("k"), 3);
    symbol A("A"), B("B");
    e = epsilon_tensor(i, j, k) * indexed(A, j) * indexed(B, k);
    cout << simplify_indexed(e) << endl;
     // -> -B.k*A.j*eps.i.k.j
    e = epsilon_tensor(i, j, k) * indexed(A, j) * indexed(A, k);
    cout << simplify_indexed(e) << endl;
     // -> 0
@}
@end example

@subsection Linear algebra

The @code{matrix} class can be used with indices to do some simple linear
algebra (linear combinations and products of vectors and matrices, traces
and scalar products):

@example
@{
    idx i(symbol("i"), 2), j(symbol("j"), 2);
    symbol x("x"), y("y");

    // A is a 2x2 matrix, X is a 2x1 vector
    matrix A(2, 2, lst(1, 2, 3, 4)), X(2, 1, lst(x, y));

    cout << indexed(A, i, i) << endl;
     // -> 5

    ex e = indexed(A, i, j) * indexed(X, j);
    cout << e.simplify_indexed() << endl;
     // -> [[2*y+x],[4*y+3*x]].i

    e = indexed(A, i, j) * indexed(X, i) + indexed(X, j) * 2;
    cout << e.simplify_indexed() << endl;
     // -> [[3*y+3*x,6*y+2*x]].j
@}
@end example

You can of course obtain the same results with the @code{matrix::add()},
@code{matrix::mul()} and @code{matrix::trace()} methods (@pxref{Matrices})
but with indices you don't have to worry about transposing matrices.

Matrix indices always start at 0 and their dimension must match the number
of rows/columns of the matrix. Matrices with one row or one column are
vectors and can have one or two indices (it doesn't matter whether it's a
row or a column vector). Other matrices must have two indices.

You should be careful when using indices with variance on matrices. GiNaC
doesn't look at the variance and doesn't know that @samp{F~mu~nu} and
@samp{F.mu.nu} are different matrices. In this case you should use only
one form for @samp{F} and explicitly multiply it with a matrix representation
of the metric tensor.


@node Non-commutative objects, Methods and Functions, Indexed objects, Basic Concepts
@c    node-name, next, previous, up
@section Non-commutative objects

GiNaC is equipped to handle certain non-commutative algebras. Three classes of
non-commutative objects are built-in which are mostly of use in high energy
physics:

@itemize
@item Clifford (Dirac) algebra (class @code{clifford})
@item su(3) Lie algebra (class @code{color})
@item Matrices (unindexed) (class @code{matrix})
@end itemize

The @code{clifford} and @code{color} classes are subclasses of
@code{indexed} because the elements of these algebras usually carry
indices. The @code{matrix} class is described in more detail in
@ref{Matrices}.

Unlike most computer algebra systems, GiNaC does not primarily provide an
operator (often denoted @samp{&*}) for representing inert products of
arbitrary objects. Rather, non-commutativity in GiNaC is a property of the
classes of objects involved, and non-commutative products are formed with
the usual @samp{*} operator, as are ordinary products. GiNaC is capable of
figuring out by itself which objects commute and will group the factors
by their class. Consider this example:

@example
    ...
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4);
    idx a(symbol("a"), 8), b(symbol("b"), 8);
    ex e = -dirac_gamma(mu) * (2*color_T(a)) * 8 * color_T(b) * dirac_gamma(nu);
    cout << e << endl;
     // -> -16*(gamma~mu*gamma~nu)*(T.a*T.b)
    ...
@end example

As can be seen, GiNaC pulls out the overall commutative factor @samp{-16} and
groups the non-commutative factors (the gammas and the su(3) generators)
together while preserving the order of factors within each class (because
Clifford objects commute with color objects). The resulting expression is a
@emph{commutative} product with two factors that are themselves non-commutative
products (@samp{gamma~mu*gamma~nu} and @samp{T.a*T.b}). For clarification,
parentheses are placed around the non-commutative products in the output.

@cindex @code{ncmul} (class)
Non-commutative products are internally represented by objects of the class
@code{ncmul}, as opposed to commutative products which are handled by the
@code{mul} class. You will normally not have to worry about this distinction,
though.

The advantage of this approach is that you never have to worry about using
(or forgetting to use) a special operator when constructing non-commutative
expressions. Also, non-commutative products in GiNaC are more intelligent
than in other computer algebra systems; they can, for example, automatically
canonicalize themselves according to rules specified in the implementation
of the non-commutative classes. The drawback is that to work with other than
the built-in algebras you have to implement new classes yourself. Symbols
always commute and it's not possible to construct non-commutative products
using symbols to represent the algebra elements or generators. User-defined
functions can, however, be specified as being non-commutative.

@cindex @code{return_type()}
@cindex @code{return_type_tinfo()}
Information about the commutativity of an object or expression can be
obtained with the two member functions

@example
unsigned ex::return_type(void) const;
unsigned ex::return_type_tinfo(void) const;
@end example

The @code{return_type()} function returns one of three values (defined in
the header file @file{flags.h}), corresponding to three categories of
expressions in GiNaC:

@itemize
@item @code{return_types::commutative}: Commutes with everything. Most GiNaC
  classes are of this kind.
@item @code{return_types::noncommutative}: Non-commutative, belonging to a
  certain class of non-commutative objects which can be determined with the
  @code{return_type_tinfo()} method. Expressions of this category commute
  with everything except @code{noncommutative} expressions of the same
  class.
@item @code{return_types::noncommutative_composite}: Non-commutative, composed
  of non-commutative objects of different classes. Expressions of this
  category don't commute with any other @code{noncommutative} or
  @code{noncommutative_composite} expressions.
@end itemize

The value returned by the @code{return_type_tinfo()} method is valid only
when the return type of the expression is @code{noncommutative}. It is a
value that is unique to the class of the object and usually one of the
constants in @file{tinfos.h}, or derived therefrom.

Here are a couple of examples:

@cartouche
@multitable @columnfractions 0.33 0.33 0.34
@item @strong{Expression} @tab @strong{@code{return_type()}} @tab @strong{@code{return_type_tinfo()}}
@item @code{42} @tab @code{commutative} @tab -
@item @code{2*x-y} @tab @code{commutative} @tab -
@item @code{dirac_ONE()} @tab @code{noncommutative} @tab @code{TINFO_clifford}
@item @code{dirac_gamma(mu)*dirac_gamma(nu)} @tab @code{noncommutative} @tab @code{TINFO_clifford}
@item @code{2*color_T(a)} @tab @code{noncommutative} @tab @code{TINFO_color}
@item @code{dirac_ONE()*color_T(a)} @tab @code{noncommutative_composite} @tab -
@end multitable
@end cartouche

Note: the @code{return_type_tinfo()} of Clifford objects is only equal to
@code{TINFO_clifford} for objects with a representation label of zero.
Other representation labels yield a different @code{return_type_tinfo()},
but it's the same for any two objects with the same label. This is also true
for color objects.

A last note: With the exception of matrices, positive integer powers of
non-commutative objects are automatically expanded in GiNaC. For example,
@code{pow(a*b, 2)} becomes @samp{a*b*a*b} if @samp{a} and @samp{b} are
non-commutative expressions).


@cindex @code{clifford} (class)
@subsection Clifford algebra

@cindex @code{dirac_gamma()}
Clifford algebra elements (also called Dirac gamma matrices, although GiNaC
doesn't treat them as matrices) are designated as @samp{gamma~mu} and satisfy
@samp{gamma~mu*gamma~nu + gamma~nu*gamma~mu = 2*eta~mu~nu} where @samp{eta~mu~nu}
is the Minkowski metric tensor. Dirac gammas are constructed by the function

@example
ex dirac_gamma(const ex & mu, unsigned char rl = 0);
@end example

which takes two arguments: the index and a @dfn{representation label} in the
range 0 to 255 which is used to distinguish elements of different Clifford
algebras (this is also called a @dfn{spin line index}). Gammas with different
labels commute with each other. The dimension of the index can be 4 or (in
the framework of dimensional regularization) any symbolic value. Spinor
indices on Dirac gammas are not supported in GiNaC.

@cindex @code{dirac_ONE()}
The unity element of a Clifford algebra is constructed by

@example
ex dirac_ONE(unsigned char rl = 0);
@end example

@strong{Note:} You must always use @code{dirac_ONE()} when referring to
multiples of the unity element, even though it's customary to omit it.
E.g. instead of @code{dirac_gamma(mu)*(dirac_slash(q,4)+m)} you have to
write @code{dirac_gamma(mu)*(dirac_slash(q,4)+m*dirac_ONE())}. Otherwise,
GiNaC may produce incorrect results.

@cindex @code{dirac_gamma5()}
There's a special element @samp{gamma5} that commutes with all other
gammas and in 4 dimensions equals @samp{gamma~0 gamma~1 gamma~2 gamma~3},
provided by

@example
ex dirac_gamma5(unsigned char rl = 0);
@end example

@cindex @code{dirac_gamma6()}
@cindex @code{dirac_gamma7()}
The two additional functions

@example
ex dirac_gamma6(unsigned char rl = 0);
ex dirac_gamma7(unsigned char rl = 0);
@end example

return @code{dirac_ONE(rl) + dirac_gamma5(rl)} and @code{dirac_ONE(rl) - dirac_gamma5(rl)},
respectively.

@cindex @code{dirac_slash()}
Finally, the function

@example
ex dirac_slash(const ex & e, const ex & dim, unsigned char rl = 0);
@end example

creates a term that represents a contraction of @samp{e} with the Dirac
Lorentz vector (it behaves like a term of the form @samp{e.mu gamma~mu}
with a unique index whose dimension is given by the @code{dim} argument).
Such slashed expressions are printed with a trailing backslash, e.g. @samp{e\}.

In products of dirac gammas, superfluous unity elements are automatically
removed, squares are replaced by their values and @samp{gamma5} is
anticommuted to the front. The @code{simplify_indexed()} function performs
contractions in gamma strings, for example

@example
@{
    ...
    symbol a("a"), b("b"), D("D");
    varidx mu(symbol("mu"), D);
    ex e = dirac_gamma(mu) * dirac_slash(a, D)
         * dirac_gamma(mu.toggle_variance());
    cout << e << endl;
     // -> gamma~mu*a\*gamma.mu
    e = e.simplify_indexed();
    cout << e << endl;
     // -> -D*a\+2*a\
    cout << e.subs(D == 4) << endl;
     // -> -2*a\
    ...
@}
@end example

@cindex @code{dirac_trace()}
To calculate the trace of an expression containing strings of Dirac gammas
you use the function

@example
ex dirac_trace(const ex & e, unsigned char rl = 0, const ex & trONE = 4);
@end example

This function takes the trace of all gammas with the specified representation
label; gammas with other labels are left standing. The last argument to
@code{dirac_trace()} is the value to be returned for the trace of the unity
element, which defaults to 4. The @code{dirac_trace()} function is a linear
functional that is equal to the usual trace only in @math{D = 4} dimensions.
In particular, the functional is not cyclic in @math{D != 4} dimensions when
acting on expressions containing @samp{gamma5}, so it's not a proper trace.
This @samp{gamma5} scheme is described in greater detail in
@cite{The Role of gamma5 in Dimensional Regularization}.

The value of the trace itself is also usually different in 4 and in
@math{D != 4} dimensions:

@example
@{
    // 4 dimensions
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4), rho(symbol("rho"), 4);
    ex e = dirac_gamma(mu) * dirac_gamma(nu) *
           dirac_gamma(mu.toggle_variance()) * dirac_gamma(rho);
    cout << dirac_trace(e).simplify_indexed() << endl;
     // -> -8*eta~rho~nu
@}
...
@{
    // D dimensions
    symbol D("D");
    varidx mu(symbol("mu"), D), nu(symbol("nu"), D), rho(symbol("rho"), D);
    ex e = dirac_gamma(mu) * dirac_gamma(nu) *
           dirac_gamma(mu.toggle_variance()) * dirac_gamma(rho);
    cout << dirac_trace(e).simplify_indexed() << endl;
     // -> 8*eta~rho~nu-4*eta~rho~nu*D
@}
@end example

Here is an example for using @code{dirac_trace()} to compute a value that
appears in the calculation of the one-loop vacuum polarization amplitude in
QED:

@example
@{
    symbol q("q"), l("l"), m("m"), ldotq("ldotq"), D("D");
    varidx mu(symbol("mu"), D), nu(symbol("nu"), D);

    scalar_products sp;
    sp.add(l, l, pow(l, 2));
    sp.add(l, q, ldotq);

    ex e = dirac_gamma(mu) *
           (dirac_slash(l, D) + dirac_slash(q, D) + m * dirac_ONE()) *    
           dirac_gamma(mu.toggle_variance()) *
           (dirac_slash(l, D) + m * dirac_ONE());   
    e = dirac_trace(e).simplify_indexed(sp);
    e = e.collect(lst(l, ldotq, m));
    cout << e << endl;
     // -> (8-4*D)*l^2+(8-4*D)*ldotq+4*D*m^2
@}
@end example

The @code{canonicalize_clifford()} function reorders all gamma products that
appear in an expression to a canonical (but not necessarily simple) form.
You can use this to compare two expressions or for further simplifications:

@example
@{
    varidx mu(symbol("mu"), 4), nu(symbol("nu"), 4);
    ex e = dirac_gamma(mu) * dirac_gamma(nu) + dirac_gamma(nu) * dirac_gamma(mu);
    cout << e << endl;
     // -> gamma~mu*gamma~nu+gamma~nu*gamma~mu

    e = canonicalize_clifford(e);
    cout << e << endl;
     // -> 2*eta~mu~nu
@}
@end example


@cindex @code{color} (class)
@subsection Color algebra

@cindex @code{color_T()}
For computations in quantum chromodynamics, GiNaC implements the base elements
and structure constants of the su(3) Lie algebra (color algebra). The base
elements @math{T_a} are constructed by the function

@example
ex color_T(const ex & a, unsigned char rl = 0);
@end example

which takes two arguments: the index and a @dfn{representation label} in the
range 0 to 255 which is used to distinguish elements of different color
algebras. Objects with different labels commute with each other. The
dimension of the index must be exactly 8 and it should be of class @code{idx},
not @code{varidx}.

@cindex @code{color_ONE()}
The unity element of a color algebra is constructed by

@example
ex color_ONE(unsigned char rl = 0);
@end example

@strong{Note:} You must always use @code{color_ONE()} when referring to
multiples of the unity element, even though it's customary to omit it.
E.g. instead of @code{color_T(a)*(color_T(b)*indexed(X,b)+1)} you have to
write @code{color_T(a)*(color_T(b)*indexed(X,b)+color_ONE())}. Otherwise,
GiNaC may produce incorrect results.

@cindex @code{color_d()}
@cindex @code{color_f()}
The functions

@example
ex color_d(const ex & a, const ex & b, const ex & c);
ex color_f(const ex & a, const ex & b, const ex & c);
@end example

create the symmetric and antisymmetric structure constants @math{d_abc} and
@math{f_abc} which satisfy @math{@{T_a, T_b@} = 1/3 delta_ab + d_abc T_c}
and @math{[T_a, T_b] = i f_abc T_c}.

@cindex @code{color_h()}
There's an additional function

@example
ex color_h(const ex & a, const ex & b, const ex & c);
@end example

which returns the linear combination @samp{color_d(a, b, c)+I*color_f(a, b, c)}.

The function @code{simplify_indexed()} performs some simplifications on
expressions containing color objects:

@example
@{
    ...
    idx a(symbol("a"), 8), b(symbol("b"), 8), c(symbol("c"), 8),
        k(symbol("k"), 8), l(symbol("l"), 8);

    e = color_d(a, b, l) * color_f(a, b, k);
    cout << e.simplify_indexed() << endl;
     // -> 0

    e = color_d(a, b, l) * color_d(a, b, k);
    cout << e.simplify_indexed() << endl;
     // -> 5/3*delta.k.l

    e = color_f(l, a, b) * color_f(a, b, k);
    cout << e.simplify_indexed() << endl;
     // -> 3*delta.k.l

    e = color_h(a, b, c) * color_h(a, b, c);
    cout << e.simplify_indexed() << endl;
     // -> -32/3

    e = color_h(a, b, c) * color_T(b) * color_T(c);
    cout << e.simplify_indexed() << endl;
     // -> -2/3*T.a

    e = color_h(a, b, c) * color_T(a) * color_T(b) * color_T(c);
    cout << e.simplify_indexed() << endl;
     // -> -8/9*ONE

    e = color_T(k) * color_T(a) * color_T(b) * color_T(k);
    cout << e.simplify_indexed() << endl;
     // -> 1/4*delta.b.a*ONE-1/6*T.a*T.b
    ...
@end example

@cindex @code{color_trace()}
To calculate the trace of an expression containing color objects you use the
function

@example
ex color_trace(const ex & e, unsigned char rl = 0);
@end example

This function takes the trace of all color @samp{T} objects with the
specified representation label; @samp{T}s with other labels are left
standing. For example:

@example
    ...
    e = color_trace(4 * color_T(a) * color_T(b) * color_T(c));
    cout << e << endl;
     // -> -I*f.a.c.b+d.a.c.b
@}
@end example


@node Methods and Functions, Information About Expressions, Non-commutative objects, Top
@c    node-name, next, previous, up
@chapter Methods and Functions
@cindex polynomial

In this chapter the most important algorithms provided by GiNaC will be
described.  Some of them are implemented as functions on expressions,
others are implemented as methods provided by expression objects.  If
they are methods, there exists a wrapper function around it, so you can
alternatively call it in a functional way as shown in the simple
example:

@example
    ...
    cout << "As method:   " << sin(1).evalf() << endl;
    cout << "As function: " << evalf(sin(1)) << endl;
    ...
@end example

@cindex @code{subs()}
The general rule is that wherever methods accept one or more parameters
(@var{arg1}, @var{arg2}, @dots{}) the order of arguments the function
wrapper accepts is the same but preceded by the object to act on
(@var{object}, @var{arg1}, @var{arg2}, @dots{}).  This approach is the
most natural one in an OO model but it may lead to confusion for MapleV
users because where they would type @code{A:=x+1; subs(x=2,A);} GiNaC
would require @code{A=x+1; subs(A,x==2);} (after proper declaration of
@code{A} and @code{x}).  On the other hand, since MapleV returns 3 on
@code{A:=x^2+3; coeff(A,x,0);} (GiNaC: @code{A=pow(x,2)+3;
coeff(A,x,0);}) it is clear that MapleV is not trying to be consistent
here.  Also, users of MuPAD will in most cases feel more comfortable
with GiNaC's convention.  All function wrappers are implemented
as simple inline functions which just call the corresponding method and
are only provided for users uncomfortable with OO who are dead set to
avoid method invocations.  Generally, nested function wrappers are much
harder to read than a sequence of methods and should therefore be
avoided if possible.  On the other hand, not everything in GiNaC is a
method on class @code{ex} and sometimes calling a function cannot be
avoided.

@menu
* Information About Expressions::
* Substituting Expressions::
* Pattern Matching and Advanced Substitutions::
* Applying a Function on Subexpressions::
* Polynomial Arithmetic::           Working with polynomials.
* Rational Expressions::            Working with rational functions.
* Symbolic Differentiation::
* Series Expansion::                Taylor and Laurent expansion.
* Symmetrization::
* Built-in Functions::              List of predefined mathematical functions.
* Input/Output::                    Input and output of expressions.
@end menu


@node Information About Expressions, Substituting Expressions, Methods and Functions, Methods and Functions
@c    node-name, next, previous, up
@section Getting information about expressions

@subsection Checking expression types
@cindex @code{is_a<@dots{}>()}
@cindex @code{is_exactly_a<@dots{}>()}
@cindex @code{ex_to<@dots{}>()}
@cindex Converting @code{ex} to other classes
@cindex @code{info()}
@cindex @code{return_type()}
@cindex @code{return_type_tinfo()}

Sometimes it's useful to check whether a given expression is a plain number,
a sum, a polynomial with integer coefficients, or of some other specific type.
GiNaC provides a couple of functions for this:

@example
bool is_a<T>(const ex & e);
bool is_exactly_a<T>(const ex & e);
bool ex::info(unsigned flag);
unsigned ex::return_type(void) const;
unsigned ex::return_type_tinfo(void) const;
@end example

When the test made by @code{is_a<T>()} returns true, it is safe to call
one of the functions @code{ex_to<T>()}, where @code{T} is one of the
class names (@xref{The Class Hierarchy}, for a list of all classes). For
example, assuming @code{e} is an @code{ex}:

@example
@{
    @dots{}
    if (is_a<numeric>(e))
        numeric n = ex_to<numeric>(e);
    @dots{}
@}
@end example

@code{is_a<T>(e)} allows you to check whether the top-level object of
an expression @samp{e} is an instance of the GiNaC class @samp{T}
(@xref{The Class Hierarchy}, for a list of all classes). This is most useful,
e.g., for checking whether an expression is a number, a sum, or a product:

@example
@{
    symbol x("x");
    ex e1 = 42;
    ex e2 = 4*x - 3;
    is_a<numeric>(e1);  // true
    is_a<numeric>(e2);  // false
    is_a<add>(e1);      // false
    is_a<add>(e2);      // true
    is_a<mul>(e1);      // false
    is_a<mul>(e2);      // false
@}
@end example

In contrast, @code{is_exactly_a<T>(e)} allows you to check whether the
top-level object of an expression @samp{e} is an instance of the GiNaC
class @samp{T}, not including parent classes.

The @code{info()} method is used for checking certain attributes of
expressions. The possible values for the @code{flag} argument are defined
in @file{ginac/flags.h}, the most important being explained in the following
table:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Flag} @tab @strong{Returns true if the object is@dots{}}
@item @code{numeric}
@tab @dots{}a number (same as @code{is_<numeric>(...)})
@item @code{real}
@tab @dots{}a real integer, rational or float (i.e. is not complex)
@item @code{rational}
@tab @dots{}an exact rational number (integers are rational, too)
@item @code{integer}
@tab @dots{}a (non-complex) integer
@item @code{crational}
@tab @dots{}an exact (complex) rational number (such as @math{2/3+7/2*I})
@item @code{cinteger}
@tab @dots{}a (complex) integer (such as @math{2-3*I})
@item @code{positive}
@tab @dots{}not complex and greater than 0
@item @code{negative}
@tab @dots{}not complex and less than 0
@item @code{nonnegative}
@tab @dots{}not complex and greater than or equal to 0
@item @code{posint}
@tab @dots{}an integer greater than 0
@item @code{negint}
@tab @dots{}an integer less than 0
@item @code{nonnegint}
@tab @dots{}an integer greater than or equal to 0
@item @code{even}
@tab @dots{}an even integer
@item @code{odd}
@tab @dots{}an odd integer
@item @code{prime}
@tab @dots{}a prime integer (probabilistic primality test)
@item @code{relation}
@tab @dots{}a relation (same as @code{is_a<relational>(...)})
@item @code{relation_equal}
@tab @dots{}a @code{==} relation
@item @code{relation_not_equal}
@tab @dots{}a @code{!=} relation
@item @code{relation_less}
@tab @dots{}a @code{<} relation
@item @code{relation_less_or_equal}
@tab @dots{}a @code{<=} relation
@item @code{relation_greater}
@tab @dots{}a @code{>} relation
@item @code{relation_greater_or_equal}
@tab @dots{}a @code{>=} relation
@item @code{symbol}
@tab @dots{}a symbol (same as @code{is_a<symbol>(...)})
@item @code{list}
@tab @dots{}a list (same as @code{is_a<lst>(...)})
@item @code{polynomial}
@tab @dots{}a polynomial (i.e. only consists of sums and products of numbers and symbols with positive integer powers)
@item @code{integer_polynomial}
@tab @dots{}a polynomial with (non-complex) integer coefficients
@item @code{cinteger_polynomial}
@tab @dots{}a polynomial with (possibly complex) integer coefficients (such as @math{2-3*I})
@item @code{rational_polynomial}
@tab @dots{}a polynomial with (non-complex) rational coefficients
@item @code{crational_polynomial}
@tab @dots{}a polynomial with (possibly complex) rational coefficients (such as @math{2/3+7/2*I})
@item @code{rational_function}
@tab @dots{}a rational function (@math{x+y}, @math{z/(x+y)})
@item @code{algebraic}
@tab @dots{}an algebraic object (@math{sqrt(2)}, @math{sqrt(x)-1})
@end multitable
@end cartouche

To determine whether an expression is commutative or non-commutative and if
so, with which other expressions it would commute, you use the methods
@code{return_type()} and @code{return_type_tinfo()}. @xref{Non-commutative objects},
for an explanation of these.


@subsection Accessing subexpressions
@cindex @code{nops()}
@cindex @code{op()}
@cindex container
@cindex @code{relational} (class)

GiNaC provides the two methods

@example
unsigned ex::nops();
ex ex::op(unsigned i);
@end example

for accessing the subexpressions in the container-like GiNaC classes like
@code{add}, @code{mul}, @code{lst}, and @code{function}. @code{nops()}
determines the number of subexpressions (@samp{operands}) contained, while
@code{op()} returns the @code{i}-th (0..@code{nops()-1}) subexpression.
In the case of a @code{power} object, @code{op(0)} will return the basis
and @code{op(1)} the exponent. For @code{indexed} objects, @code{op(0)}
is the base expression and @code{op(i)}, @math{i>0} are the indices.

The left-hand and right-hand side expressions of objects of class
@code{relational} (and only of these) can also be accessed with the methods

@example
ex ex::lhs();
ex ex::rhs();
@end example


@subsection Comparing expressions
@cindex @code{is_equal()}
@cindex @code{is_zero()}

Expressions can be compared with the usual C++ relational operators like
@code{==}, @code{>}, and @code{<} but if the expressions contain symbols,
the result is usually not determinable and the result will be @code{false},
except in the case of the @code{!=} operator. You should also be aware that
GiNaC will only do the most trivial test for equality (subtracting both
expressions), so something like @code{(pow(x,2)+x)/x==x+1} will return
@code{false}.

Actually, if you construct an expression like @code{a == b}, this will be
represented by an object of the @code{relational} class (@pxref{Relations})
which is not evaluated until (explicitly or implicitly) cast to a @code{bool}.

There are also two methods

@example
bool ex::is_equal(const ex & other);
bool ex::is_zero();
@end example

for checking whether one expression is equal to another, or equal to zero,
respectively.

@strong{Warning:} You will also find an @code{ex::compare()} method in the
GiNaC header files. This method is however only to be used internally by
GiNaC to establish a canonical sort order for terms, and using it to compare
expressions will give very surprising results.


@node Substituting Expressions, Pattern Matching and Advanced Substitutions, Information About Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Substituting expressions
@cindex @code{subs()}

Algebraic objects inside expressions can be replaced with arbitrary
expressions via the @code{.subs()} method:

@example
ex ex::subs(const ex & e);
ex ex::subs(const lst & syms, const lst & repls);
@end example

In the first form, @code{subs()} accepts a relational of the form
@samp{object == expression} or a @code{lst} of such relationals:

@example
@{
    symbol x("x"), y("y");

    ex e1 = 2*x^2-4*x+3;
    cout << "e1(7) = " << e1.subs(x == 7) << endl;
     // -> 73

    ex e2 = x*y + x;
    cout << "e2(-2, 4) = " << e2.subs(lst(x == -2, y == 4)) << endl;
     // -> -10
@}
@end example

If you specify multiple substitutions, they are performed in parallel, so e.g.
@code{subs(lst(x == y, y == x))} exchanges @samp{x} and @samp{y}.

The second form of @code{subs()} takes two lists, one for the objects to be
replaced and one for the expressions to be substituted (both lists must
contain the same number of elements). Using this form, you would write
@code{subs(lst(x, y), lst(y, x))} to exchange @samp{x} and @samp{y}.

@code{subs()} performs syntactic substitution of any complete algebraic
object; it does not try to match sub-expressions as is demonstrated by the
following example:

@example
@{
    symbol x("x"), y("y"), z("z");

    ex e1 = pow(x+y, 2);
    cout << e1.subs(x+y == 4) << endl;
     // -> 16

    ex e2 = sin(x)*sin(y)*cos(x);
    cout << e2.subs(sin(x) == cos(x)) << endl;
     // -> cos(x)^2*sin(y)

    ex e3 = x+y+z;
    cout << e3.subs(x+y == 4) << endl;
     // -> x+y+z
     // (and not 4+z as one might expect)
@}
@end example

A more powerful form of substitution using wildcards is described in the
next section.


@node Pattern Matching and Advanced Substitutions, Applying a Function on Subexpressions, Substituting Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Pattern matching and advanced substitutions
@cindex @code{wildcard} (class)
@cindex Pattern matching

GiNaC allows the use of patterns for checking whether an expression is of a
certain form or contains subexpressions of a certain form, and for
substituting expressions in a more general way.

A @dfn{pattern} is an algebraic expression that optionally contains wildcards.
A @dfn{wildcard} is a special kind of object (of class @code{wildcard}) that
represents an arbitrary expression. Every wildcard has a @dfn{label} which is
an unsigned integer number to allow having multiple different wildcards in a
pattern. Wildcards are printed as @samp{$label} (this is also the way they
are specified in @command{ginsh}). In C++ code, wildcard objects are created
with the call

@example
ex wild(unsigned label = 0);
@end example

which is simply a wrapper for the @code{wildcard()} constructor with a shorter
name.

Some examples for patterns:

@multitable @columnfractions .5 .5
@item @strong{Constructed as} @tab @strong{Output as}
@item @code{wild()} @tab @samp{$0}
@item @code{pow(x,wild())} @tab @samp{x^$0}
@item @code{atan2(wild(1),wild(2))} @tab @samp{atan2($1,$2)}
@item @code{indexed(A,idx(wild(),3))} @tab @samp{A.$0}
@end multitable

Notes:

@itemize
@item Wildcards behave like symbols and are subject to the same algebraic
  rules. E.g., @samp{$0+2*$0} is automatically transformed to @samp{3*$0}.
@item As shown in the last example, to use wildcards for indices you have to
  use them as the value of an @code{idx} object. This is because indices must
  always be of class @code{idx} (or a subclass).
@item Wildcards only represent expressions or subexpressions. It is not
  possible to use them as placeholders for other properties like index
  dimension or variance, representation labels, symmetry of indexed objects
  etc.
@item Because wildcards are commutative, it is not possible to use wildcards
  as part of noncommutative products.
@item A pattern does not have to contain wildcards. @samp{x} and @samp{x+y}
  are also valid patterns.
@end itemize

@cindex @code{match()}
The most basic application of patterns is to check whether an expression
matches a given pattern. This is done by the function

@example
bool ex::match(const ex & pattern);
bool ex::match(const ex & pattern, lst & repls);
@end example

This function returns @code{true} when the expression matches the pattern
and @code{false} if it doesn't. If used in the second form, the actual
subexpressions matched by the wildcards get returned in the @code{repls}
object as a list of relations of the form @samp{wildcard == expression}.
If @code{match()} returns false, the state of @code{repls} is undefined.
For reproducible results, the list should be empty when passed to
@code{match()}, but it is also possible to find similarities in multiple
expressions by passing in the result of a previous match.

The matching algorithm works as follows:

@itemize
@item A single wildcard matches any expression. If one wildcard appears
  multiple times in a pattern, it must match the same expression in all
  places (e.g. @samp{$0} matches anything, and @samp{$0*($0+1)} matches
  @samp{x*(x+1)} but not @samp{x*(y+1)}).
@item If the expression is not of the same class as the pattern, the match
  fails (i.e. a sum only matches a sum, a function only matches a function,
  etc.).
@item If the pattern is a function, it only matches the same function
  (i.e. @samp{sin($0)} matches @samp{sin(x)} but doesn't match @samp{exp(x)}).
@item Except for sums and products, the match fails if the number of
  subexpressions (@code{nops()}) is not equal to the number of subexpressions
  of the pattern.
@item If there are no subexpressions, the expressions and the pattern must
  be equal (in the sense of @code{is_equal()}).
@item Except for sums and products, each subexpression (@code{op()}) must
  match the corresponding subexpression of the pattern.
@end itemize

Sums (@code{add}) and products (@code{mul}) are treated in a special way to
account for their commutativity and associativity:

@itemize
@item If the pattern contains a term or factor that is a single wildcard,
  this one is used as the @dfn{global wildcard}. If there is more than one
  such wildcard, one of them is chosen as the global wildcard in a random
  way.
@item Every term/factor of the pattern, except the global wildcard, is
  matched against every term of the expression in sequence. If no match is
  found, the whole match fails. Terms that did match are not considered in
  further matches.
@item If there are no unmatched terms left, the match succeeds. Otherwise
  the match fails unless there is a global wildcard in the pattern, in
  which case this wildcard matches the remaining terms.
@end itemize

In general, having more than one single wildcard as a term of a sum or a
factor of a product (such as @samp{a+$0+$1}) will lead to unpredictable or
ambiguous results.

Here are some examples in @command{ginsh} to demonstrate how it works (the
@code{match()} function in @command{ginsh} returns @samp{FAIL} if the
match fails, and the list of wildcard replacements otherwise):

@example
> match((x+y)^a,(x+y)^a);
@{@}
> match((x+y)^a,(x+y)^b);
FAIL
> match((x+y)^a,$1^$2);
@{$1==x+y,$2==a@}
> match((x+y)^a,$1^$1);
FAIL
> match((x+y)^(x+y),$1^$1);
@{$1==x+y@}
> match((x+y)^(x+y),$1^$2);
@{$1==x+y,$2==x+y@}
> match((a+b)*(a+c),($1+b)*($1+c));
@{$1==a@}
> match((a+b)*(a+c),(a+$1)*(a+$2));
@{$1==c,$2==b@}
  (Unpredictable. The result might also be [$1==c,$2==b].)
> match((a+b)*(a+c),($1+$2)*($1+$3));
  (The result is undefined. Due to the sequential nature of the algorithm
   and the re-ordering of terms in GiNaC, the match for the first factor
   may be @{$1==a,$2==b@} in which case the match for the second factor
   succeeds, or it may be @{$1==b,$2==a@} which causes the second match to
   fail.)
> match(a*(x+y)+a*z+b,a*$1+$2);
  (This is also ambiguous and may return either @{$1==z,$2==a*(x+y)+b@} or
   @{$1=x+y,$2=a*z+b@}.)
> match(a+b+c+d+e+f,c);
FAIL
> match(a+b+c+d+e+f,c+$0);
@{$0==a+e+b+f+d@}
> match(a+b+c+d+e+f,c+e+$0);
@{$0==a+b+f+d@}
> match(a+b,a+b+$0);
@{$0==0@}
> match(a*b^2,a^$1*b^$2);
FAIL
  (The matching is syntactic, not algebraic, and "a" doesn't match "a^$1"
   even though a==a^1.)
> match(x*atan2(x,x^2),$0*atan2($0,$0^2));
@{$0==x@}
> match(atan2(y,x^2),atan2(y,$0));
@{$0==x^2@}
@end example

@cindex @code{has()}
A more general way to look for patterns in expressions is provided by the
member function

@example
bool ex::has(const ex & pattern);
@end example

This function checks whether a pattern is matched by an expression itself or
by any of its subexpressions.

Again some examples in @command{ginsh} for illustration (in @command{ginsh},
@code{has()} returns @samp{1} for @code{true} and @samp{0} for @code{false}):

@example
> has(x*sin(x+y+2*a),y);
1
> has(x*sin(x+y+2*a),x+y);
0
  (This is because in GiNaC, "x+y" is not a subexpression of "x+y+2*a" (which
   has the subexpressions "x", "y" and "2*a".)
> has(x*sin(x+y+2*a),x+y+$1);
1
  (But this is possible.)
> has(x*sin(2*(x+y)+2*a),x+y);
0
  (This fails because "2*(x+y)" automatically gets converted to "2*x+2*y" of
   which "x+y" is not a subexpression.)
> has(x+1,x^$1);
0
  (Although x^1==x and x^0==1, neither "x" nor "1" are actually of the form
   "x^something".)
> has(4*x^2-x+3,$1*x);
1
> has(4*x^2+x+3,$1*x);
0
  (Another possible pitfall. The first expression matches because the term
   "-x" has the form "(-1)*x" in GiNaC. To check whether a polynomial
   contains a linear term you should use the coeff() function instead.)
@end example

@cindex @code{find()}
The method

@example
bool ex::find(const ex & pattern, lst & found);
@end example

works a bit like @code{has()} but it doesn't stop upon finding the first
match. Instead, it appends all found matches to the specified list. If there
are multiple occurrences of the same expression, it is entered only once to
the list. @code{find()} returns false if no matches were found (in
@command{ginsh}, it returns an empty list):

@example
> find(1+x+x^2+x^3,x);
@{x@}
> find(1+x+x^2+x^3,y);
@{@}
> find(1+x+x^2+x^3,x^$1);
@{x^3,x^2@}
  (Note the absence of "x".)
> expand((sin(x)+sin(y))*(a+b));
sin(y)*a+sin(x)*b+sin(x)*a+sin(y)*b
> find(%,sin($1));
@{sin(y),sin(x)@}
@end example

@cindex @code{subs()}
Probably the most useful application of patterns is to use them for
substituting expressions with the @code{subs()} method. Wildcards can be
used in the search patterns as well as in the replacement expressions, where
they get replaced by the expressions matched by them. @code{subs()} doesn't
know anything about algebra; it performs purely syntactic substitutions.

Some examples:

@example
> subs(a^2+b^2+(x+y)^2,$1^2==$1^3);
b^3+a^3+(x+y)^3
> subs(a^4+b^4+(x+y)^4,$1^2==$1^3);
b^4+a^4+(x+y)^4
> subs((a+b+c)^2,a+b==x);
(a+b+c)^2
> subs((a+b+c)^2,a+b+$1==x+$1);
(x+c)^2
> subs(a+2*b,a+b==x);
a+2*b
> subs(4*x^3-2*x^2+5*x-1,x==a);
-1+5*a-2*a^2+4*a^3
> subs(4*x^3-2*x^2+5*x-1,x^$0==a^$0);
-1+5*x-2*a^2+4*a^3
> subs(sin(1+sin(x)),sin($1)==cos($1));
cos(1+cos(x))
> expand(subs(a*sin(x+y)^2+a*cos(x+y)^2+b,cos($1)^2==1-sin($1)^2));
a+b
@end example

The last example would be written in C++ in this way:

@example
@{
    symbol a("a"), b("b"), x("x"), y("y");
    e = a*pow(sin(x+y), 2) + a*pow(cos(x+y), 2) + b;
    e = e.subs(pow(cos(wild()), 2) == 1-pow(sin(wild()), 2));
    cout << e.expand() << endl;
     // -> a+b
@}
@end example


@node Applying a Function on Subexpressions, Polynomial Arithmetic, Pattern Matching and Advanced Substitutions, Methods and Functions
@c    node-name, next, previous, up
@section Applying a Function on Subexpressions
@cindex Tree traversal
@cindex @code{map()}

Sometimes you may want to perform an operation on specific parts of an
expression while leaving the general structure of it intact. An example
of this would be a matrix trace operation: the trace of a sum is the sum
of the traces of the individual terms. That is, the trace should @dfn{map}
on the sum, by applying itself to each of the sum's operands. It is possible
to do this manually which usually results in code like this:

@example
ex calc_trace(ex e)
@{
    if (is_a<matrix>(e))
        return ex_to<matrix>(e).trace();
    else if (is_a<add>(e)) @{
        ex sum = 0;
        for (unsigned i=0; i<e.nops(); i++)
            sum += calc_trace(e.op(i));
        return sum;
    @} else if (is_a<mul>)(e)) @{
        ...
    @} else @{
        ...
    @}
@}
@end example

This is, however, slightly inefficient (if the sum is very large it can take
a long time to add the terms one-by-one), and its applicability is limited to
a rather small class of expressions. If @code{calc_trace()} is called with
a relation or a list as its argument, you will probably want the trace to
be taken on both sides of the relation or of all elements of the list.

GiNaC offers the @code{map()} method to aid in the implementation of such
operations:

@example
ex ex::map(map_function & f) const;
ex ex::map(ex (*f)(const ex & e)) const;
@end example

In the first (preferred) form, @code{map()} takes a function object that
is subclassed from the @code{map_function} class. In the second form, it
takes a pointer to a function that accepts and returns an expression.
@code{map()} constructs a new expression of the same type, applying the
specified function on all subexpressions (in the sense of @code{op()}),
non-recursively.

The use of a function object makes it possible to supply more arguments to
the function that is being mapped, or to keep local state information.
The @code{map_function} class declares a virtual function call operator
that you can overload. Here is a sample implementation of @code{calc_trace()}
that uses @code{map()} in a recursive fashion:

@example
struct calc_trace : public map_function @{
    ex operator()(const ex &e)
    @{
        if (is_a<matrix>(e))
            return ex_to<matrix>(e).trace();
        else if (is_a<mul>(e)) @{
            ...
        @} else
            return e.map(*this);
    @}
@};
@end example

This function object could then be used like this:

@example
@{
    ex M = ... // expression with matrices
    calc_trace do_trace;
    ex tr = do_trace(M);
@}
@end example

Here is another example for you to meditate over.  It removes quadratic
terms in a variable from an expanded polynomial:

@example
struct map_rem_quad : public map_function @{
    ex var;
    map_rem_quad(const ex & var_) : var(var_) @{@}

    ex operator()(const ex & e)
    @{
        if (is_a<add>(e) || is_a<mul>(e))
     	    return e.map(*this);
        else if (is_a<power>(e) && 
                 e.op(0).is_equal(var) && e.op(1).info(info_flags::even))
            return 0;
        else
            return e;
    @}
@};

...

@{
    symbol x("x"), y("y");

    ex e;
    for (int i=0; i<8; i++)
        e += pow(x, i) * pow(y, 8-i) * (i+1);
    cout << e << endl;
     // -> 4*y^5*x^3+5*y^4*x^4+8*y*x^7+7*y^2*x^6+2*y^7*x+6*y^3*x^5+3*y^6*x^2+y^8

    map_rem_quad rem_quad(x);
    cout << rem_quad(e) << endl;
     // -> 4*y^5*x^3+8*y*x^7+2*y^7*x+6*y^3*x^5+y^8
@}
@end example

@command{ginsh} offers a slightly different implementation of @code{map()}
that allows applying algebraic functions to operands. The second argument
to @code{map()} is an expression containing the wildcard @samp{$0} which
acts as the placeholder for the operands:

@example
> map(a*b,sin($0));
sin(a)*sin(b)
> map(a+2*b,sin($0));
sin(a)+sin(2*b)
> map(@{a,b,c@},$0^2+$0);
@{a^2+a,b^2+b,c^2+c@}
@end example

Note that it is only possible to use algebraic functions in the second
argument. You can not use functions like @samp{diff()}, @samp{op()},
@samp{subs()} etc. because these are evaluated immediately:

@example
> map(@{a,b,c@},diff($0,a));
@{0,0,0@}
  This is because "diff($0,a)" evaluates to "0", so the command is equivalent
  to "map(@{a,b,c@},0)".
@end example


@node Polynomial Arithmetic, Rational Expressions, Applying a Function on Subexpressions, Methods and Functions
@c    node-name, next, previous, up
@section Polynomial arithmetic

@subsection Expanding and collecting
@cindex @code{expand()}
@cindex @code{collect()}

A polynomial in one or more variables has many equivalent
representations.  Some useful ones serve a specific purpose.  Consider
for example the trivariate polynomial @math{4*x*y + x*z + 20*y^2 +
21*y*z + 4*z^2} (written down here in output-style).  It is equivalent
to the factorized polynomial @math{(x + 5*y + 4*z)*(4*y + z)}.  Other
representations are the recursive ones where one collects for exponents
in one of the three variable.  Since the factors are themselves
polynomials in the remaining two variables the procedure can be
repeated.  In our example, two possibilities would be @math{(4*y + z)*x
+ 20*y^2 + 21*y*z + 4*z^2} and @math{20*y^2 + (21*z + 4*x)*y + 4*z^2 +
x*z}.

To bring an expression into expanded form, its method

@example
ex ex::expand();
@end example

may be called.  In our example above, this corresponds to @math{4*x*y +
x*z + 20*y^2 + 21*y*z + 4*z^2}.  Again, since the canonical form in
GiNaC is not easily guessable you should be prepared to see different
orderings of terms in such sums!

Another useful representation of multivariate polynomials is as a
univariate polynomial in one of the variables with the coefficients
being polynomials in the remaining variables.  The method
@code{collect()} accomplishes this task:

@example
ex ex::collect(const ex & s, bool distributed = false);
@end example

The first argument to @code{collect()} can also be a list of objects in which
case the result is either a recursively collected polynomial, or a polynomial
in a distributed form with terms like @math{c*x1^e1*...*xn^en}, as specified
by the @code{distributed} flag.

Note that the original polynomial needs to be in expanded form (for the
variables concerned) in order for @code{collect()} to be able to find the
coefficients properly.

The following @command{ginsh} transcript shows an application of @code{collect()}
together with @code{find()}:

@example
> a=expand((sin(x)+sin(y))*(1+p+q)*(1+d));
d*p*sin(x)+p*sin(x)+q*d*sin(x)+q*sin(y)+d*sin(x)+q*d*sin(y)+sin(y)+d*sin(y)+q*sin(x)+d*sin(y)*p+sin(x)+sin(y)*p
> collect(a,@{p,q@});
d*sin(x)+(d*sin(x)+sin(y)+d*sin(y)+sin(x))*p+(d*sin(x)+sin(y)+d*sin(y)+sin(x))*q+sin(y)+d*sin(y)+sin(x)
> collect(a,find(a,sin($1)));
(1+q+d+q*d+d*p+p)*sin(y)+(1+q+d+q*d+d*p+p)*sin(x)
> collect(a,@{find(a,sin($1)),p,q@});
(1+(1+d)*p+d+q*(1+d))*sin(x)+(1+(1+d)*p+d+q*(1+d))*sin(y)
> collect(a,@{find(a,sin($1)),d@});
(1+q+d*(1+q+p)+p)*sin(y)+(1+q+d*(1+q+p)+p)*sin(x)
@end example

@subsection Degree and coefficients
@cindex @code{degree()}
@cindex @code{ldegree()}
@cindex @code{coeff()}

The degree and low degree of a polynomial can be obtained using the two
methods

@example
int ex::degree(const ex & s);
int ex::ldegree(const ex & s);
@end example

which also work reliably on non-expanded input polynomials (they even work
on rational functions, returning the asymptotic degree). To extract
a coefficient with a certain power from an expanded polynomial you use

@example
ex ex::coeff(const ex & s, int n);
@end example

You can also obtain the leading and trailing coefficients with the methods

@example
ex ex::lcoeff(const ex & s);
ex ex::tcoeff(const ex & s);
@end example

which are equivalent to @code{coeff(s, degree(s))} and @code{coeff(s, ldegree(s))},
respectively.

An application is illustrated in the next example, where a multivariate
polynomial is analyzed:

@example
@{
    symbol x("x"), y("y");
    ex PolyInp = 4*pow(x,3)*y + 5*x*pow(y,2) + 3*y
                 - pow(x+y,2) + 2*pow(y+2,2) - 8;
    ex Poly = PolyInp.expand();
    
    for (int i=Poly.ldegree(x); i<=Poly.degree(x); ++i) @{
        cout << "The x^" << i << "-coefficient is "
             << Poly.coeff(x,i) << endl;
    @}
    cout << "As polynomial in y: " 
         << Poly.collect(y) << endl;
@}
@end example

When run, it returns an output in the following fashion:

@example
The x^0-coefficient is y^2+11*y
The x^1-coefficient is 5*y^2-2*y
The x^2-coefficient is -1
The x^3-coefficient is 4*y
As polynomial in y: -x^2+(5*x+1)*y^2+(-2*x+4*x^3+11)*y
@end example

As always, the exact output may vary between different versions of GiNaC
or even from run to run since the internal canonical ordering is not
within the user's sphere of influence.

@code{degree()}, @code{ldegree()}, @code{coeff()}, @code{lcoeff()},
@code{tcoeff()} and @code{collect()} can also be used to a certain degree
with non-polynomial expressions as they not only work with symbols but with
constants, functions and indexed objects as well:

@example
@{
    symbol a("a"), b("b"), c("c");
    idx i(symbol("i"), 3);

    ex e = pow(sin(x) - cos(x), 4);
    cout << e.degree(cos(x)) << endl;
     // -> 4
    cout << e.expand().coeff(sin(x), 3) << endl;
     // -> -4*cos(x)

    e = indexed(a+b, i) * indexed(b+c, i); 
    e = e.expand(expand_options::expand_indexed);
    cout << e.collect(indexed(b, i)) << endl;
     // -> a.i*c.i+(a.i+c.i)*b.i+b.i^2
@}
@end example


@subsection Polynomial division
@cindex polynomial division
@cindex quotient
@cindex remainder
@cindex pseudo-remainder
@cindex @code{quo()}
@cindex @code{rem()}
@cindex @code{prem()}
@cindex @code{divide()}

The two functions

@example
ex quo(const ex & a, const ex & b, const symbol & x);
ex rem(const ex & a, const ex & b, const symbol & x);
@end example

compute the quotient and remainder of univariate polynomials in the variable
@samp{x}. The results satisfy @math{a = b*quo(a, b, x) + rem(a, b, x)}.

The additional function

@example
ex prem(const ex & a, const ex & b, const symbol & x);
@end example

computes the pseudo-remainder of @samp{a} and @samp{b} which satisfies
@math{c*a = b*q + prem(a, b, x)}, where @math{c = b.lcoeff(x) ^ (a.degree(x) - b.degree(x) + 1)}.

Exact division of multivariate polynomials is performed by the function

@example
bool divide(const ex & a, const ex & b, ex & q);
@end example

If @samp{b} divides @samp{a} over the rationals, this function returns @code{true}
and returns the quotient in the variable @code{q}. Otherwise it returns @code{false}
in which case the value of @code{q} is undefined.


@subsection Unit, content and primitive part
@cindex @code{unit()}
@cindex @code{content()}
@cindex @code{primpart()}

The methods

@example
ex ex::unit(const symbol & x);
ex ex::content(const symbol & x);
ex ex::primpart(const symbol & x);
@end example

return the unit part, content part, and primitive polynomial of a multivariate
polynomial with respect to the variable @samp{x} (the unit part being the sign
of the leading coefficient, the content part being the GCD of the coefficients,
and the primitive polynomial being the input polynomial divided by the unit and
content parts). The product of unit, content, and primitive part is the
original polynomial.


@subsection GCD and LCM
@cindex GCD
@cindex LCM
@cindex @code{gcd()}
@cindex @code{lcm()}

The functions for polynomial greatest common divisor and least common
multiple have the synopsis

@example
ex gcd(const ex & a, const ex & b);
ex lcm(const ex & a, const ex & b);
@end example

The functions @code{gcd()} and @code{lcm()} accept two expressions
@code{a} and @code{b} as arguments and return a new expression, their
greatest common divisor or least common multiple, respectively.  If the
polynomials @code{a} and @code{b} are coprime @code{gcd(a,b)} returns 1
and @code{lcm(a,b)} returns the product of @code{a} and @code{b}.

@example
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex P_a = 4*x*y + x*z + 20*pow(y, 2) + 21*y*z + 4*pow(z, 2);
    ex P_b = x*y + 3*x*z + 5*pow(y, 2) + 19*y*z + 12*pow(z, 2);

    ex P_gcd = gcd(P_a, P_b);
    // x + 5*y + 4*z
    ex P_lcm = lcm(P_a, P_b);
    // 4*x*y^2 + 13*y*x*z + 20*y^3 + 81*y^2*z + 67*y*z^2 + 3*x*z^2 + 12*z^3
@}
@end example


@subsection Square-free decomposition
@cindex square-free decomposition
@cindex factorization
@cindex @code{sqrfree()}

GiNaC still lacks proper factorization support.  Some form of
factorization is, however, easily implemented by noting that factors
appearing in a polynomial with power two or more also appear in the
derivative and hence can easily be found by computing the GCD of the
original polynomial and its derivatives.  Any decent system has an
interface for this so called square-free factorization.  So we provide
one, too:
@example
ex sqrfree(const ex & a, const lst & l = lst());
@end example
Here is an example that by the way illustrates how the exact form of the
result may slightly depend on the order of differentiation, calling for
some care with subsequent processing of the result:
@example
    ...
    symbol x("x"), y("y");
    ex BiVarPol = expand(pow(2-2*y,3) * pow(1+x*y,2) * pow(x-2*y,2) * (x+y));

    cout << sqrfree(BiVarPol, lst(x,y)) << endl;
     // -> 8*(1-y)^3*(y*x^2-2*y+x*(1-2*y^2))^2*(y+x)

    cout << sqrfree(BiVarPol, lst(y,x)) << endl;
     // -> 8*(1-y)^3*(-y*x^2+2*y+x*(-1+2*y^2))^2*(y+x)

    cout << sqrfree(BiVarPol) << endl;
     // -> depending on luck, any of the above
    ...
@end example
Note also, how factors with the same exponents are not fully factorized
with this method.


@node Rational Expressions, Symbolic Differentiation, Polynomial Arithmetic, Methods and Functions
@c    node-name, next, previous, up
@section Rational expressions

@subsection The @code{normal} method
@cindex @code{normal()}
@cindex simplification
@cindex temporary replacement

Some basic form of simplification of expressions is called for frequently.
GiNaC provides the method @code{.normal()}, which converts a rational function
into an equivalent rational function of the form @samp{numerator/denominator}
where numerator and denominator are coprime.  If the input expression is already
a fraction, it just finds the GCD of numerator and denominator and cancels it,
otherwise it performs fraction addition and multiplication.

@code{.normal()} can also be used on expressions which are not rational functions
as it will replace all non-rational objects (like functions or non-integer
powers) by temporary symbols to bring the expression to the domain of rational
functions before performing the normalization, and re-substituting these
symbols afterwards. This algorithm is also available as a separate method
@code{.to_rational()}, described below.

This means that both expressions @code{t1} and @code{t2} are indeed
simplified in this little code snippet:

@example
@{
    symbol x("x");
    ex t1 = (pow(x,2) + 2*x + 1)/(x + 1);
    ex t2 = (pow(sin(x),2) + 2*sin(x) + 1)/(sin(x) + 1);
    std::cout << "t1 is " << t1.normal() << std::endl;
    std::cout << "t2 is " << t2.normal() << std::endl;
@}
@end example

Of course this works for multivariate polynomials too, so the ratio of
the sample-polynomials from the section about GCD and LCM above would be
normalized to @code{P_a/P_b} = @code{(4*y+z)/(y+3*z)}.


@subsection Numerator and denominator
@cindex numerator
@cindex denominator
@cindex @code{numer()}
@cindex @code{denom()}
@cindex @code{numer_denom()}

The numerator and denominator of an expression can be obtained with

@example
ex ex::numer();
ex ex::denom();
ex ex::numer_denom();
@end example

These functions will first normalize the expression as described above and
then return the numerator, denominator, or both as a list, respectively.
If you need both numerator and denominator, calling @code{numer_denom()} is
faster than using @code{numer()} and @code{denom()} separately.


@subsection Converting to a rational expression
@cindex @code{to_rational()}

Some of the methods described so far only work on polynomials or rational
functions. GiNaC provides a way to extend the domain of these functions to
general expressions by using the temporary replacement algorithm described
above. You do this by calling

@example
ex ex::to_rational(lst &l);
@end example

on the expression to be converted. The supplied @code{lst} will be filled
with the generated temporary symbols and their replacement expressions in
a format that can be used directly for the @code{subs()} method. It can also
already contain a list of replacements from an earlier application of
@code{.to_rational()}, so it's possible to use it on multiple expressions
and get consistent results.

For example,

@example
@{
    symbol x("x");
    ex a = pow(sin(x), 2) - pow(cos(x), 2);
    ex b = sin(x) + cos(x);
    ex q;
    lst l;
    divide(a.to_rational(l), b.to_rational(l), q);
    cout << q.subs(l) << endl;
@}
@end example

will print @samp{sin(x)-cos(x)}.


@node Symbolic Differentiation, Series Expansion, Rational Expressions, Methods and Functions
@c    node-name, next, previous, up
@section Symbolic differentiation
@cindex differentiation
@cindex @code{diff()}
@cindex chain rule
@cindex product rule

GiNaC's objects know how to differentiate themselves.  Thus, a
polynomial (class @code{add}) knows that its derivative is the sum of
the derivatives of all the monomials:

@example
@{
    symbol x("x"), y("y"), z("z");
    ex P = pow(x, 5) + pow(x, 2) + y;

    cout << P.diff(x,2) << endl;
     // -> 20*x^3 + 2
    cout << P.diff(y) << endl;    // 1
     // -> 1
    cout << P.diff(z) << endl;    // 0
     // -> 0
@}
@end example

If a second integer parameter @var{n} is given, the @code{diff} method
returns the @var{n}th derivative.

If @emph{every} object and every function is told what its derivative
is, all derivatives of composed objects can be calculated using the
chain rule and the product rule.  Consider, for instance the expression
@code{1/cosh(x)}.  Since the derivative of @code{cosh(x)} is
@code{sinh(x)} and the derivative of @code{pow(x,-1)} is
@code{-pow(x,-2)}, GiNaC can readily compute the composition.  It turns
out that the composition is the generating function for Euler Numbers,
i.e. the so called @var{n}th Euler number is the coefficient of
@code{x^n/n!} in the expansion of @code{1/cosh(x)}.  We may use this
identity to code a function that generates Euler numbers in just three
lines:

@cindex Euler numbers
@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex EulerNumber(unsigned n)
@{
    symbol x;
    const ex generator = pow(cosh(x),-1);
    return generator.diff(x,n).subs(x==0);
@}

int main()
@{
    for (unsigned i=0; i<11; i+=2)
        std::cout << EulerNumber(i) << std::endl;
    return 0;
@}
@end example

When you run it, it produces the sequence @code{1}, @code{-1}, @code{5},
@code{-61}, @code{1385}, @code{-50521}.  We increment the loop variable
@code{i} by two since all odd Euler numbers vanish anyways.


@node Series Expansion, Symmetrization, Symbolic Differentiation, Methods and Functions
@c    node-name, next, previous, up
@section Series expansion
@cindex @code{series()}
@cindex Taylor expansion
@cindex Laurent expansion
@cindex @code{pseries} (class)
@cindex @code{Order()}

Expressions know how to expand themselves as a Taylor series or (more
generally) a Laurent series.  As in most conventional Computer Algebra
Systems, no distinction is made between those two.  There is a class of
its own for storing such series (@code{class pseries}) and a built-in
function (called @code{Order}) for storing the order term of the series.
As a consequence, if you want to work with series, i.e. multiply two
series, you need to call the method @code{ex::series} again to convert
it to a series object with the usual structure (expansion plus order
term).  A sample application from special relativity could read:

@example
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol v("v"), c("c");
    
    ex gamma = 1/sqrt(1 - pow(v/c,2));
    ex mass_nonrel = gamma.series(v==0, 10);
    
    cout << "the relativistic mass increase with v is " << endl
         << mass_nonrel << endl;
    
    cout << "the inverse square of this series is " << endl
         << pow(mass_nonrel,-2).series(v==0, 10) << endl;
@}
@end example

Only calling the series method makes the last output simplify to
@math{1-v^2/c^2+O(v^10)}, without that call we would just have a long
series raised to the power @math{-2}.

@cindex M@'echain's formula
As another instructive application, let us calculate the numerical 
value of Archimedes' constant
@tex
$\pi$
@end tex
(for which there already exists the built-in constant @code{Pi}) 
using M@'echain's amazing formula
@tex
$\pi=16$~atan~$\!\left(1 \over 5 \right)-4$~atan~$\!\left(1 \over 239 \right)$.
@end tex
@ifnottex
@math{Pi==16*atan(1/5)-4*atan(1/239)}.
@end ifnottex
We may expand the arcus tangent around @code{0} and insert the fractions
@code{1/5} and @code{1/239}.  But, as we have seen, a series in GiNaC
carries an order term with it and the question arises what the system is
supposed to do when the fractions are plugged into that order term.  The
solution is to use the function @code{series_to_poly()} to simply strip
the order term off:

@example
#include <ginac/ginac.h>
using namespace GiNaC;

ex mechain_pi(int degr)
@{
    symbol x;
    ex pi_expansion = series_to_poly(atan(x).series(x,degr));
    ex pi_approx = 16*pi_expansion.subs(x==numeric(1,5))
                   -4*pi_expansion.subs(x==numeric(1,239));
    return pi_approx;
@}

int main()
@{
    using std::cout;  // just for fun, another way of...
    using std::endl;  // ...dealing with this namespace std.
    ex pi_frac;
    for (int i=2; i<12; i+=2) @{
        pi_frac = mechain_pi(i);
        cout << i << ":\t" << pi_frac << endl
             << "\t" << pi_frac.evalf() << endl;
    @}
    return 0;
@}
@end example

Note how we just called @code{.series(x,degr)} instead of
@code{.series(x==0,degr)}.  This is a simple shortcut for @code{ex}'s
method @code{series()}: if the first argument is a symbol the expression
is expanded in that symbol around point @code{0}.  When you run this
program, it will type out:

@example
2:      3804/1195
        3.1832635983263598326
4:      5359397032/1706489875
        3.1405970293260603143
6:      38279241713339684/12184551018734375
        3.141621029325034425
8:      76528487109180192540976/24359780855939418203125
        3.141591772182177295
10:     327853873402258685803048818236/104359128170408663038552734375
        3.1415926824043995174
@end example


@node Symmetrization, Built-in Functions, Series Expansion, Methods and Functions
@c    node-name, next, previous, up
@section Symmetrization
@cindex @code{symmetrize()}
@cindex @code{antisymmetrize()}
@cindex @code{symmetrize_cyclic()}

The three methods

@example
ex ex::symmetrize(const lst & l);
ex ex::antisymmetrize(const lst & l);
ex ex::symmetrize_cyclic(const lst & l);
@end example

symmetrize an expression by returning the sum over all symmetric,
antisymmetric or cyclic permutations of the specified list of objects,
weighted by the number of permutations.

The three additional methods

@example
ex ex::symmetrize();
ex ex::antisymmetrize();
ex ex::symmetrize_cyclic();
@end example

symmetrize or antisymmetrize an expression over its free indices.

Symmetrization is most useful with indexed expressions but can be used with
almost any kind of object (anything that is @code{subs()}able):

@example
@{
    idx i(symbol("i"), 3), j(symbol("j"), 3), k(symbol("k"), 3);
    symbol A("A"), B("B"), a("a"), b("b"), c("c");
                                           
    cout << indexed(A, i, j).symmetrize() << endl;
     // -> 1/2*A.j.i+1/2*A.i.j
    cout << indexed(A, i, j, k).antisymmetrize(lst(i, j)) << endl;
     // -> -1/2*A.j.i.k+1/2*A.i.j.k
    cout << lst(a, b, c).symmetrize_cyclic(lst(a, b, c)) << endl;
     // -> 1/3*@{a,b,c@}+1/3*@{b,c,a@}+1/3*@{c,a,b@}
@}
@end example


@node Built-in Functions, Input/Output, Symmetrization, Methods and Functions
@c    node-name, next, previous, up
@section Predefined mathematical functions

GiNaC contains the following predefined mathematical functions:

@cartouche
@multitable @columnfractions .30 .70
@item @strong{Name} @tab @strong{Function}
@item @code{abs(x)}
@tab absolute value
@cindex @code{abs()}
@item @code{csgn(x)}
@tab complex sign
@cindex @code{csgn()}
@item @code{sqrt(x)}
@tab square root (not a GiNaC function, rather an alias for @code{pow(x, numeric(1, 2))})
@cindex @code{sqrt()}
@item @code{sin(x)}
@tab sine
@cindex @code{sin()}
@item @code{cos(x)}
@tab cosine
@cindex @code{cos()}
@item @code{tan(x)}
@tab tangent
@cindex @code{tan()}
@item @code{asin(x)}
@tab inverse sine
@cindex @code{asin()}
@item @code{acos(x)}
@tab inverse cosine
@cindex @code{acos()}
@item @code{atan(x)}
@tab inverse tangent
@cindex @code{atan()}
@item @code{atan2(y, x)}
@tab inverse tangent with two arguments
@item @code{sinh(x)}
@tab hyperbolic sine
@cindex @code{sinh()}
@item @code{cosh(x)}
@tab hyperbolic cosine
@cindex @code{cosh()}
@item @code{tanh(x)}
@tab hyperbolic tangent
@cindex @code{tanh()}
@item @code{asinh(x)}
@tab inverse hyperbolic sine
@cindex @code{asinh()}
@item @code{acosh(x)}
@tab inverse hyperbolic cosine
@cindex @code{acosh()}
@item @code{atanh(x)}
@tab inverse hyperbolic tangent
@cindex @code{atanh()}
@item @code{exp(x)}
@tab exponential function
@cindex @code{exp()}
@item @code{log(x)}
@tab natural logarithm
@cindex @code{log()}
@item @code{Li2(x)}
@tab Dilogarithm
@cindex @code{Li2()}
@item @code{zeta(x)}
@tab Riemann's zeta function
@cindex @code{zeta()}
@item @code{zeta(n, x)}
@tab derivatives of Riemann's zeta function
@item @code{tgamma(x)}
@tab Gamma function
@cindex @code{tgamma()}
@cindex Gamma function
@item @code{lgamma(x)}
@tab logarithm of Gamma function
@cindex @code{lgamma()}
@item @code{beta(x, y)}
@tab Beta function (@code{tgamma(x)*tgamma(y)/tgamma(x+y)})
@cindex @code{beta()}
@item @code{psi(x)}
@tab psi (digamma) function
@cindex @code{psi()}
@item @code{psi(n, x)}
@tab derivatives of psi function (polygamma functions)
@item @code{factorial(n)}
@tab factorial function
@cindex @code{factorial()}
@item @code{binomial(n, m)}
@tab binomial coefficients
@cindex @code{binomial()}
@item @code{Order(x)}
@tab order term function in truncated power series
@cindex @code{Order()}
@end multitable
@end cartouche

@cindex branch cut
For functions that have a branch cut in the complex plane GiNaC follows
the conventions for C++ as defined in the ANSI standard as far as
possible.  In particular: the natural logarithm (@code{log}) and the
square root (@code{sqrt}) both have their branch cuts running along the
negative real axis where the points on the axis itself belong to the
upper part (i.e. continuous with quadrant II).  The inverse
trigonometric and hyperbolic functions are not defined for complex
arguments by the C++ standard, however.  In GiNaC we follow the
conventions used by CLN, which in turn follow the carefully designed
definitions in the Common Lisp standard.  It should be noted that this
convention is identical to the one used by the C99 standard and by most
serious CAS.  It is to be expected that future revisions of the C++
standard incorporate these functions in the complex domain in a manner
compatible with C99.


@node Input/Output, Extending GiNaC, Built-in Functions, Methods and Functions
@c    node-name, next, previous, up
@section Input and output of expressions
@cindex I/O

@subsection Expression output
@cindex printing
@cindex output of expressions

The easiest way to print an expression is to write it to a stream:

@example
@{
    symbol x("x");
    ex e = 4.5+pow(x,2)*3/2;
    cout << e << endl;    // prints '(4.5)+3/2*x^2'
    // ...
@end example

The output format is identical to the @command{ginsh} input syntax and
to that used by most computer algebra systems, but not directly pastable
into a GiNaC C++ program (note that in the above example, @code{pow(x,2)}
is printed as @samp{x^2}).

It is possible to print expressions in a number of different formats with
the method

@example
void ex::print(const print_context & c, unsigned level = 0);
@end example

@cindex @code{print_context} (class)
The type of @code{print_context} object passed in determines the format
of the output. The possible types are defined in @file{ginac/print.h}.
All constructors of @code{print_context} and derived classes take an
@code{ostream &} as their first argument.

To print an expression in a way that can be directly used in a C or C++
program, you pass a @code{print_csrc} object like this:

@example
    // ...
    cout << "float f = ";
    e.print(print_csrc_float(cout));
    cout << ";\n";

    cout << "double d = ";
    e.print(print_csrc_double(cout));
    cout << ";\n";

    cout << "cl_N n = ";
    e.print(print_csrc_cl_N(cout));
    cout << ";\n";
    // ...
@end example

The three possible types mostly affect the way in which floating point
numbers are written.

The above example will produce (note the @code{x^2} being converted to @code{x*x}):

@example
float f = (3.000000e+00/2.000000e+00)*(x*x)+4.500000e+00;
double d = (3.000000e+00/2.000000e+00)*(x*x)+4.500000e+00;
cl_N n = (cln::cl_F("3.0")/cln::cl_F("2.0"))*(x*x)+cln::cl_F("4.5");
@end example

The @code{print_context} type @code{print_tree} provides a dump of the
internal structure of an expression for debugging purposes:

@example
    // ...
    e.print(print_tree(cout));
@}
@end example

produces

@example
add, hash=0x0, flags=0x3, nops=2
    power, hash=0x9, flags=0x3, nops=2
        x (symbol), serial=3, hash=0x44a113a6, flags=0xf
        2 (numeric), hash=0x80000042, flags=0xf
    3/2 (numeric), hash=0x80000061, flags=0xf
    -----
    overall_coeff
    4.5L0 (numeric), hash=0x8000004b, flags=0xf
    =====
@end example

This kind of output is also available in @command{ginsh} as the @code{print()}
function.

Another useful output format is for LaTeX parsing in mathematical mode.
It is rather similar to the default @code{print_context} but provides
some braces needed by LaTeX for delimiting boxes and also converts some
common objects to conventional LaTeX names. It is possible to give symbols
a special name for LaTeX output by supplying it as a second argument to
the @code{symbol} constructor.

For example, the code snippet

@example
    // ...
    symbol x("x");
    ex foo = lgamma(x).series(x==0,3);
    foo.print(print_latex(std::cout));
@end example

will print out:

@example
    @{(-\ln(x))@}+@{(-\gamma_E)@} x+@{(1/12 \pi^2)@} x^@{2@}+\mathcal@{O@}(x^3)
@end example

@cindex Tree traversal
If you need any fancy special output format, e.g. for interfacing GiNaC
with other algebra systems or for producing code for different
programming languages, you can always traverse the expression tree yourself:

@example
static void my_print(const ex & e)
@{
    if (is_a<function>(e))
        cout << ex_to<function>(e).get_name();
    else
        cout << e.bp->class_name();
    cout << "(";
    unsigned n = e.nops();
    if (n)
        for (unsigned i=0; i<n; i++) @{
            my_print(e.op(i));
            if (i != n-1)
                cout << ",";
        @}
    else
        cout << e;
    cout << ")";
@}

int main(void)
@{
    my_print(pow(3, x) - 2 * sin(y / Pi)); cout << endl;
    return 0;
@}
@end example

This will produce

@example
add(power(numeric(3),symbol(x)),mul(sin(mul(power(constant(Pi),numeric(-1)),
symbol(y))),numeric(-2)))
@end example

If you need an output format that makes it possible to accurately
reconstruct an expression by feeding the output to a suitable parser or
object factory, you should consider storing the expression in an
@code{archive} object and reading the object properties from there.
See the section on archiving for more information.


@subsection Expression input
@cindex input of expressions

GiNaC provides no way to directly read an expression from a stream because
you will usually want the user to be able to enter something like @samp{2*x+sin(y)}
and have the @samp{x} and @samp{y} correspond to the symbols @code{x} and
@code{y} you defined in your program and there is no way to specify the
desired symbols to the @code{>>} stream input operator.

Instead, GiNaC lets you construct an expression from a string, specifying the
list of symbols to be used:

@example
@{
    symbol x("x"), y("y");
    ex e("2*x+sin(y)", lst(x, y));
@}
@end example

The input syntax is the same as that used by @command{ginsh} and the stream
output operator @code{<<}. The symbols in the string are matched by name to
the symbols in the list and if GiNaC encounters a symbol not specified in
the list it will throw an exception.

With this constructor, it's also easy to implement interactive GiNaC programs:

@example
#include <iostream>
#include <string>
#include <stdexcept>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol x("x");
    string s;

    cout << "Enter an expression containing 'x': ";
    getline(cin, s);

    try @{
        ex e(s, lst(x));
        cout << "The derivative of " << e << " with respect to x is ";
        cout << e.diff(x) << ".\n";
    @} catch (exception &p) @{
        cerr << p.what() << endl;
    @}
@}
@end example


@subsection Archiving
@cindex @code{archive} (class)
@cindex archiving

GiNaC allows creating @dfn{archives} of expressions which can be stored
to or retrieved from files. To create an archive, you declare an object
of class @code{archive} and archive expressions in it, giving each
expression a unique name:

@example
#include <fstream>
using namespace std;
#include <ginac/ginac.h>
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");

    ex foo = sin(x + 2*y) + 3*z + 41;
    ex bar = foo + 1;

    archive a;
    a.archive_ex(foo, "foo");
    a.archive_ex(bar, "the second one");
    // ...
@end example

The archive can then be written to a file:

@example
    // ...
    ofstream out("foobar.gar");
    out << a;
    out.close();
    // ...
@end example

The file @file{foobar.gar} contains all information that is needed to
reconstruct the expressions @code{foo} and @code{bar}.

@cindex @command{viewgar}
The tool @command{viewgar} that comes with GiNaC can be used to view
the contents of GiNaC archive files:

@example
$ viewgar foobar.gar
foo = 41+sin(x+2*y)+3*z
the second one = 42+sin(x+2*y)+3*z
@end example

The point of writing archive files is of course that they can later be
read in again:

@example
    // ...
    archive a2;
    ifstream in("foobar.gar");
    in >> a2;
    // ...
@end example

And the stored expressions can be retrieved by their name:

@example
    // ...
    lst syms(x, y);

    ex ex1 = a2.unarchive_ex(syms, "foo");
    ex ex2 = a2.unarchive_ex(syms, "the second one");

    cout << ex1 << endl;              // prints "41+sin(x+2*y)+3*z"
    cout << ex2 << endl;              // prints "42+sin(x+2*y)+3*z"
    cout << ex1.subs(x == 2) << endl; // prints "41+sin(2+2*y)+3*z"
@}
@end example

Note that you have to supply a list of the symbols which are to be inserted
in the expressions. Symbols in archives are stored by their name only and
if you don't specify which symbols you have, unarchiving the expression will
create new symbols with that name. E.g. if you hadn't included @code{x} in
the @code{syms} list above, the @code{ex1.subs(x == 2)} statement would
have had no effect because the @code{x} in @code{ex1} would have been a
different symbol than the @code{x} which was defined at the beginning of
the program, although both would appear as @samp{x} when printed.

You can also use the information stored in an @code{archive} object to
output expressions in a format suitable for exact reconstruction. The
@code{archive} and @code{archive_node} classes have a couple of member
functions that let you access the stored properties:

@example
static void my_print2(const archive_node & n)
@{
    string class_name;
    n.find_string("class", class_name);
    cout << class_name << "(";

    archive_node::propinfovector p;
    n.get_properties(p);

    unsigned num = p.size();
    for (unsigned i=0; i<num; i++) @{
        const string &name = p[i].name;
        if (name == "class")
            continue;
        cout << name << "=";

        unsigned count = p[i].count;
        if (count > 1)
            cout << "@{";

        for (unsigned j=0; j<count; j++) @{
            switch (p[i].type) @{
                case archive_node::PTYPE_BOOL: @{
                    bool x;
                    n.find_bool(name, x, j);
                    cout << (x ? "true" : "false");
                    break;
                @}
                case archive_node::PTYPE_UNSIGNED: @{
                    unsigned x;
                    n.find_unsigned(name, x, j);
                    cout << x;
                    break;
                @}
                case archive_node::PTYPE_STRING: @{
                    string x;
                    n.find_string(name, x, j);
                    cout << '\"' << x << '\"';
                    break;
                @}
                case archive_node::PTYPE_NODE: @{
                    const archive_node &x = n.find_ex_node(name, j);
                    my_print2(x);
                    break;
                @}
            @}

            if (j != count-1)
                cout << ",";
        @}

        if (count > 1)
            cout << "@}";

        if (i != num-1)
            cout << ",";
    @}

    cout << ")";
@}

int main(void)
@{
    ex e = pow(2, x) - y;
    archive ar(e, "e");
    my_print2(ar.get_top_node(0)); cout << endl;
    return 0;
@}
@end example

This will produce:

@example
add(rest=@{power(basis=numeric(number="2"),exponent=symbol(name="x")),
symbol(name="y")@},coeff=@{numeric(number="1"),numeric(number="-1")@},
overall_coeff=numeric(number="0"))
@end example

Be warned, however, that the set of properties and their meaning for each
class may change between GiNaC versions.


@node Extending GiNaC, What does not belong into GiNaC, Input/Output, Top
@c    node-name, next, previous, up
@chapter Extending GiNaC

By reading so far you should have gotten a fairly good understanding of
GiNaC's design-patterns.  From here on you should start reading the
sources.  All we can do now is issue some recommendations how to tackle
GiNaC's many loose ends in order to fulfill everybody's dreams.  If you
develop some useful extension please don't hesitate to contact the GiNaC
authors---they will happily incorporate them into future versions.

@menu
* What does not belong into GiNaC::  What to avoid.
* Symbolic functions::               Implementing symbolic functions.
* Adding classes::                   Defining new algebraic classes.
@end menu


@node What does not belong into GiNaC, Symbolic functions, Extending GiNaC, Extending GiNaC
@c    node-name, next, previous, up
@section What doesn't belong into GiNaC

@cindex @command{ginsh}
First of all, GiNaC's name must be read literally.  It is designed to be
a library for use within C++.  The tiny @command{ginsh} accompanying
GiNaC makes this even more clear: it doesn't even attempt to provide a
language.  There are no loops or conditional expressions in
@command{ginsh}, it is merely a window into the library for the
programmer to test stuff (or to show off).  Still, the design of a
complete CAS with a language of its own, graphical capabilities and all
this on top of GiNaC is possible and is without doubt a nice project for
the future.

There are many built-in functions in GiNaC that do not know how to
evaluate themselves numerically to a precision declared at runtime
(using @code{Digits}).  Some may be evaluated at certain points, but not
generally.  This ought to be fixed.  However, doing numerical
computations with GiNaC's quite abstract classes is doomed to be
inefficient.  For this purpose, the underlying foundation classes
provided by CLN are much better suited.


@node Symbolic functions, Adding classes, What does not belong into GiNaC, Extending GiNaC
@c    node-name, next, previous, up
@section Symbolic functions

The easiest and most instructive way to start with is probably to
implement your own function.  GiNaC's functions are objects of class
@code{function}.  The preprocessor is then used to convert the function
names to objects with a corresponding serial number that is used
internally to identify them.  You usually need not worry about this
number.  New functions may be inserted into the system via a kind of
`registry'.  It is your responsibility to care for some functions that
are called when the user invokes certain methods.  These are usual
C++-functions accepting a number of @code{ex} as arguments and returning
one @code{ex}.  As an example, if we have a look at a simplified
implementation of the cosine trigonometric function, we first need a
function that is called when one wishes to @code{eval} it.  It could
look something like this:

@example
static ex cos_eval_method(const ex & x)
@{
    // if (!x%(2*Pi)) return 1
    // if (!x%Pi) return -1
    // if (!x%Pi/2) return 0
    // care for other cases...
    return cos(x).hold();
@}
@end example

@cindex @code{hold()}
@cindex evaluation
The last line returns @code{cos(x)} if we don't know what else to do and
stops a potential recursive evaluation by saying @code{.hold()}, which
sets a flag to the expression signaling that it has been evaluated.  We
should also implement a method for numerical evaluation and since we are
lazy we sweep the problem under the rug by calling someone else's
function that does so, in this case the one in class @code{numeric}:

@example
static ex cos_evalf(const ex & x)
@{
    if (is_a<numeric>(x))
        return cos(ex_to<numeric>(x));
    else
        return cos(x).hold();
@}
@end example

Differentiation will surely turn up and so we need to tell @code{cos}
what the first derivative is (higher derivatives (@code{.diff(x,3)} for
instance are then handled automatically by @code{basic::diff} and
@code{ex::diff}):

@example
static ex cos_deriv(const ex & x, unsigned diff_param)
@{
    return -sin(x);
@}
@end example

@cindex product rule
The second parameter is obligatory but uninteresting at this point.  It
specifies which parameter to differentiate in a partial derivative in
case the function has more than one parameter and its main application
is for correct handling of the chain rule.  For Taylor expansion, it is
enough to know how to differentiate.  But if the function you want to
implement does have a pole somewhere in the complex plane, you need to
write another method for Laurent expansion around that point.

Now that all the ingredients for @code{cos} have been set up, we need
to tell the system about it.  This is done by a macro and we are not
going to describe how it expands, please consult your preprocessor if you
are curious:

@example
REGISTER_FUNCTION(cos, eval_func(cos_eval).
                       evalf_func(cos_evalf).
                       derivative_func(cos_deriv));
@end example

The first argument is the function's name used for calling it and for
output.  The second binds the corresponding methods as options to this
object.  Options are separated by a dot and can be given in an arbitrary
order.  GiNaC functions understand several more options which are always
specified as @code{.option(params)}, for example a method for series
expansion @code{.series_func(cos_series)}.  Again, if no series
expansion method is given, GiNaC defaults to simple Taylor expansion,
which is correct if there are no poles involved as is the case for the
@code{cos} function.  The way GiNaC handles poles in case there are any
is best understood by studying one of the examples, like the Gamma
(@code{tgamma}) function for instance.  (In essence the function first
checks if there is a pole at the evaluation point and falls back to
Taylor expansion if there isn't.  Then, the pole is regularized by some
suitable transformation.)  Also, the new function needs to be declared
somewhere.  This may also be done by a convenient preprocessor macro:

@example
DECLARE_FUNCTION_1P(cos)
@end example

The suffix @code{_1P} stands for @emph{one parameter}.  Of course, this
implementation of @code{cos} is very incomplete and lacks several safety
mechanisms.  Please, have a look at the real implementation in GiNaC.
(By the way: in case you are worrying about all the macros above we can
assure you that functions are GiNaC's most macro-intense classes.  We
have done our best to avoid macros where we can.)


@node Adding classes, A Comparison With Other CAS, Symbolic functions, Extending GiNaC
@c    node-name, next, previous, up
@section Adding classes

If you are doing some very specialized things with GiNaC you may find that
you have to implement your own algebraic classes to fit your needs. This
section will explain how to do this by giving the example of a simple
'string' class. After reading this section you will know how to properly
declare a GiNaC class and what the minimum required member functions are
that you have to implement. We only cover the implementation of a 'leaf'
class here (i.e. one that doesn't contain subexpressions). Creating a
container class like, for example, a class representing tensor products is
more involved but this section should give you enough information so you can
consult the source to GiNaC's predefined classes if you want to implement
something more complicated.

@subsection GiNaC's run-time type information system

@cindex hierarchy of classes
@cindex RTTI
All algebraic classes (that is, all classes that can appear in expressions)
in GiNaC are direct or indirect subclasses of the class @code{basic}. So a
@code{basic *} (which is essentially what an @code{ex} is) represents a
generic pointer to an algebraic class. Occasionally it is necessary to find
out what the class of an object pointed to by a @code{basic *} really is.
Also, for the unarchiving of expressions it must be possible to find the
@code{unarchive()} function of a class given the class name (as a string). A
system that provides this kind of information is called a run-time type
information (RTTI) system. The C++ language provides such a thing (see the
standard header file @file{<typeinfo>}) but for efficiency reasons GiNaC
implements its own, simpler RTTI.

The RTTI in GiNaC is based on two mechanisms:

@itemize @bullet

@item
The @code{basic} class declares a member variable @code{tinfo_key} which
holds an unsigned integer that identifies the object's class. These numbers
are defined in the @file{tinfos.h} header file for the built-in GiNaC
classes. They all start with @code{TINFO_}.

@item
By means of some clever tricks with static members, GiNaC maintains a list
of information for all classes derived from @code{basic}. The information
available includes the class names, the @code{tinfo_key}s, and pointers
to the unarchiving functions. This class registry is defined in the
@file{registrar.h} header file.

@end itemize

The disadvantage of this proprietary RTTI implementation is that there's
a little more to do when implementing new classes (C++'s RTTI works more
or less automatic) but don't worry, most of the work is simplified by
macros.

@subsection A minimalistic example

Now we will start implementing a new class @code{mystring} that allows
placing character strings in algebraic expressions (this is not very useful,
but it's just an example). This class will be a direct subclass of
@code{basic}. You can use this sample implementation as a starting point
for your own classes.

The code snippets given here assume that you have included some header files
as follows:

@example
#include <iostream>
#include <string>   
#include <stdexcept>
using namespace std;

#include <ginac/ginac.h>
using namespace GiNaC;
@end example

The first thing we have to do is to define a @code{tinfo_key} for our new
class. This can be any arbitrary unsigned number that is not already taken
by one of the existing classes but it's better to come up with something
that is unlikely to clash with keys that might be added in the future. The
numbers in @file{tinfos.h} are modeled somewhat after the class hierarchy
which is not a requirement but we are going to stick with this scheme:

@example
const unsigned TINFO_mystring = 0x42420001U;
@end example

Now we can write down the class declaration. The class stores a C++
@code{string} and the user shall be able to construct a @code{mystring}
object from a C or C++ string:

@example
class mystring : public basic
@{
    GINAC_DECLARE_REGISTERED_CLASS(mystring, basic)
  
public:
    mystring(const string &s);
    mystring(const char *s);

private:
    string str;
@};

GINAC_IMPLEMENT_REGISTERED_CLASS(mystring, basic)
@end example

The @code{GINAC_DECLARE_REGISTERED_CLASS} and @code{GINAC_IMPLEMENT_REGISTERED_CLASS}
macros are defined in @file{registrar.h}.  They take the name of the class
and its direct superclass as arguments and insert all required declarations
for the RTTI system. The @code{GINAC_DECLARE_REGISTERED_CLASS} should be
the first line after the opening brace of the class definition. The
@code{GINAC_IMPLEMENT_REGISTERED_CLASS} may appear anywhere else in the
source (at global scope, of course, not inside a function).

@code{GINAC_DECLARE_REGISTERED_CLASS} contains, among other things the
declarations of the default and copy constructor, the destructor, the
assignment operator and a couple of other functions that are required.  It
also defines a type @code{inherited} which refers to the superclass so you
don't have to modify your code every time you shuffle around the class
hierarchy.  @code{GINAC_IMPLEMENT_REGISTERED_CLASS} implements the copy
constructor, the destructor and the assignment operator.

Now there are nine member functions we have to implement to get a working
class:

@itemize

@item
@code{mystring()}, the default constructor.

@item
@code{void destroy(bool call_parent)}, which is used in the destructor and the
assignment operator to free dynamically allocated members. The @code{call_parent}
specifies whether the @code{destroy()} function of the superclass is to be
called also.

@item
@code{void copy(const mystring &other)}, which is used in the copy constructor
and assignment operator to copy the member variables over from another
object of the same class.

@item
@code{void archive(archive_node &n)}, the archiving function. This stores all
information needed to reconstruct an object of this class inside an
@code{archive_node}.

@item
@code{mystring(const archive_node &n, const lst &sym_lst)}, the unarchiving
constructor. This constructs an instance of the class from the information
found in an @code{archive_node}.

@item
@code{ex unarchive(const archive_node &n, const lst &sym_lst)}, the static
unarchiving function. It constructs a new instance by calling the unarchiving
constructor.

@item
@code{int compare_same_type(const basic &other)}, which is used internally
by GiNaC to establish a canonical sort order for terms. It returns 0, +1 or
-1, depending on the relative order of this object and the @code{other}
object. If it returns 0, the objects are considered equal.
@strong{Note:} This has nothing to do with the (numeric) ordering
relationship expressed by @code{<}, @code{>=} etc (which cannot be defined
for non-numeric classes). For example, @code{numeric(1).compare_same_type(numeric(2))}
may return +1 even though 1 is clearly smaller than 2. Every GiNaC class
must provide a @code{compare_same_type()} function, even those representing
objects for which no reasonable algebraic ordering relationship can be
defined.

@item
And, of course, @code{mystring(const string &s)} and @code{mystring(const char *s)}
which are the two constructors we declared.

@end itemize

Let's proceed step-by-step. The default constructor looks like this:

@example
mystring::mystring() : inherited(TINFO_mystring)
@{
    // dynamically allocate resources here if required
@}
@end example

The golden rule is that in all constructors you have to set the
@code{tinfo_key} member to the @code{TINFO_*} value of your class. Otherwise
it will be set by the constructor of the superclass and all hell will break
loose in the RTTI. For your convenience, the @code{basic} class provides
a constructor that takes a @code{tinfo_key} value, which we are using here
(remember that in our case @code{inherited = basic}).  If the superclass
didn't have such a constructor, we would have to set the @code{tinfo_key}
to the right value manually.

In the default constructor you should set all other member variables to
reasonable default values (we don't need that here since our @code{str}
member gets set to an empty string automatically). The constructor(s) are of
course also the right place to allocate any dynamic resources you require.

Next, the @code{destroy()} function:

@example
void mystring::destroy(bool call_parent)
@{
    // free dynamically allocated resources here if required
    if (call_parent)
        inherited::destroy(call_parent);
@}
@end example

This function is where we free all dynamically allocated resources.  We
don't have any so we're not doing anything here, but if we had, for
example, used a C-style @code{char *} to store our string, this would be
the place to @code{delete[]} the string storage. If @code{call_parent}
is true, we have to call the @code{destroy()} function of the superclass
after we're done (to mimic C++'s automatic invocation of superclass
destructors where @code{destroy()} is called from outside a destructor).

The @code{copy()} function just copies over the member variables from
another object:

@example
void mystring::copy(const mystring &other)
@{
    inherited::copy(other);
    str = other.str;
@}
@end example

We can simply overwrite the member variables here. There's no need to worry
about dynamically allocated storage.  The assignment operator (which is
automatically defined by @code{GINAC_IMPLEMENT_REGISTERED_CLASS}, as you
recall) calls @code{destroy()} before it calls @code{copy()}. You have to
explicitly call the @code{copy()} function of the superclass here so
all the member variables will get copied.

Next are the three functions for archiving. You have to implement them even
if you don't plan to use archives, but the minimum required implementation
is really simple.  First, the archiving function:

@example
void mystring::archive(archive_node &n) const
@{
    inherited::archive(n);
    n.add_string("string", str);
@}
@end example

The only thing that is really required is calling the @code{archive()}
function of the superclass. Optionally, you can store all information you
deem necessary for representing the object into the passed
@code{archive_node}.  We are just storing our string here. For more
information on how the archiving works, consult the @file{archive.h} header
file.

The unarchiving constructor is basically the inverse of the archiving
function:

@example
mystring::mystring(const archive_node &n, const lst &sym_lst) : inherited(n, sym_lst)
@{
    n.find_string("string", str);
@}
@end example

If you don't need archiving, just leave this function empty (but you must
invoke the unarchiving constructor of the superclass). Note that we don't
have to set the @code{tinfo_key} here because it is done automatically
by the unarchiving constructor of the @code{basic} class.

Finally, the unarchiving function:

@example
ex mystring::unarchive(const archive_node &n, const lst &sym_lst)
@{
    return (new mystring(n, sym_lst))->setflag(status_flags::dynallocated);
@}
@end example

You don't have to understand how exactly this works. Just copy these
four lines into your code literally (replacing the class name, of
course).  It calls the unarchiving constructor of the class and unless
you are doing something very special (like matching @code{archive_node}s
to global objects) you don't need a different implementation. For those
who are interested: setting the @code{dynallocated} flag puts the object
under the control of GiNaC's garbage collection.  It will get deleted
automatically once it is no longer referenced.

Our @code{compare_same_type()} function uses a provided function to compare
the string members:

@example
int mystring::compare_same_type(const basic &other) const
@{
    const mystring &o = static_cast<const mystring &>(other);
    int cmpval = str.compare(o.str);
    if (cmpval == 0)
        return 0;
    else if (cmpval < 0)
        return -1;
    else
        return 1;
@}
@end example

Although this function takes a @code{basic &}, it will always be a reference
to an object of exactly the same class (objects of different classes are not
comparable), so the cast is safe. If this function returns 0, the two objects
are considered equal (in the sense that @math{A-B=0}), so you should compare
all relevant member variables.

Now the only thing missing is our two new constructors:

@example
mystring::mystring(const string &s) : inherited(TINFO_mystring), str(s)
@{
    // dynamically allocate resources here if required
@}

mystring::mystring(const char *s) : inherited(TINFO_mystring), str(s)
@{
    // dynamically allocate resources here if required
@}
@end example

No surprises here. We set the @code{str} member from the argument and
remember to pass the right @code{tinfo_key} to the @code{basic} constructor.

That's it! We now have a minimal working GiNaC class that can store
strings in algebraic expressions. Let's confirm that the RTTI works:

@example
ex e = mystring("Hello, world!");
cout << is_a<mystring>(e) << endl;
 // -> 1 (true)

cout << e.bp->class_name() << endl;
 // -> mystring
@end example

Obviously it does. Let's see what the expression @code{e} looks like:

@example
cout << e << endl;
 // -> [mystring object]
@end example

Hm, not exactly what we expect, but of course the @code{mystring} class
doesn't yet know how to print itself. This is done in the @code{print()}
member function. Let's say that we wanted to print the string surrounded
by double quotes:

@example
class mystring : public basic
@{
    ...
public:
    void print(const print_context &c, unsigned level = 0) const;
    ...
@};

void mystring::print(const print_context &c, unsigned level) const
@{
    // print_context::s is a reference to an ostream
    c.s << '\"' << str << '\"';
@}
@end example

The @code{level} argument is only required for container classes to
correctly parenthesize the output. Let's try again to print the expression:

@example
cout << e << endl;
 // -> "Hello, world!"
@end example

Much better. The @code{mystring} class can be used in arbitrary expressions:

@example
e += mystring("GiNaC rulez"); 
cout << e << endl;
 // -> "GiNaC rulez"+"Hello, world!"
@end example

(GiNaC's automatic term reordering is in effect here), or even

@example
e = pow(mystring("One string"), 2*sin(Pi-mystring("Another string")));
cout << e << endl;
 // -> "One string"^(2*sin(-"Another string"+Pi))
@end example

Whether this makes sense is debatable but remember that this is only an
example. At least it allows you to implement your own symbolic algorithms
for your objects.

Note that GiNaC's algebraic rules remain unchanged:

@example
e = mystring("Wow") * mystring("Wow");
cout << e << endl;
 // -> "Wow"^2

e = pow(mystring("First")-mystring("Second"), 2);
cout << e.expand() << endl;
 // -> -2*"First"*"Second"+"First"^2+"Second"^2
@end example

There's no way to, for example, make GiNaC's @code{add} class perform string
concatenation. You would have to implement this yourself.

@subsection Automatic evaluation

@cindex @code{hold()}
@cindex @code{eval()}
@cindex evaluation
When dealing with objects that are just a little more complicated than the
simple string objects we have implemented, chances are that you will want to
have some automatic simplifications or canonicalizations performed on them.
This is done in the evaluation member function @code{eval()}. Let's say that
we wanted all strings automatically converted to lowercase with
non-alphabetic characters stripped, and empty strings removed:

@example
class mystring : public basic
@{
    ...
public:
    ex eval(int level = 0) const;
    ...
@};

ex mystring::eval(int level) const
@{
    string new_str;
    for (int i=0; i<str.length(); i++) @{
        char c = str[i];
        if (c >= 'A' && c <= 'Z') 
            new_str += tolower(c);
        else if (c >= 'a' && c <= 'z')
            new_str += c;
    @}

    if (new_str.length() == 0)
        return 0;
    else
        return mystring(new_str).hold();
@}
@end example

The @code{level} argument is used to limit the recursion depth of the
evaluation.  We don't have any subexpressions in the @code{mystring}
class so we are not concerned with this.  If we had, we would call the
@code{eval()} functions of the subexpressions with @code{level - 1} as
the argument if @code{level != 1}.  The @code{hold()} member function
sets a flag in the object that prevents further evaluation.  Otherwise
we might end up in an endless loop.  When you want to return the object
unmodified, use @code{return this->hold();}.

Let's confirm that it works:

@example
ex e = mystring("Hello, world!") + mystring("!?#");
cout << e << endl;
 // -> "helloworld"

e = mystring("Wow!") + mystring("WOW") + mystring(" W ** o ** W");  
cout << e << endl;
 // -> 3*"wow"
@end example

@subsection Other member functions

We have implemented only a small set of member functions to make the class
work in the GiNaC framework. For a real algebraic class, there are probably
some more functions that you will want to re-implement, such as
@code{evalf()}, @code{series()} or @code{op()}. Have a look at @file{basic.h}
or the header file of the class you want to make a subclass of to see
what's there. One member function that you will most likely want to
implement for terminal classes like the described string class is
@code{calcchash()} that returns an @code{unsigned} hash value for the object
which will allow GiNaC to compare and canonicalize expressions much more
efficiently.

You can, of course, also add your own new member functions. Remember,
that the RTTI may be used to get information about what kinds of objects
you are dealing with (the position in the class hierarchy) and that you
can always extract the bare object from an @code{ex} by stripping the
@code{ex} off using the @code{ex_to<mystring>(e)} function when that
should become a need.

That's it. May the source be with you!


@node A Comparison With Other CAS, Advantages, Adding classes, Top
@c    node-name, next, previous, up
@chapter A Comparison With Other CAS
@cindex advocacy

This chapter will give you some information on how GiNaC compares to
other, traditional Computer Algebra Systems, like @emph{Maple},
@emph{Mathematica} or @emph{Reduce}, where it has advantages and
disadvantages over these systems.

@menu
* Advantages::                       Strengths of the GiNaC approach.
* Disadvantages::                    Weaknesses of the GiNaC approach.
* Why C++?::                         Attractiveness of C++.
@end menu

@node Advantages, Disadvantages, A Comparison With Other CAS, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Advantages

GiNaC has several advantages over traditional Computer
Algebra Systems, like 

@itemize @bullet

@item
familiar language: all common CAS implement their own proprietary
grammar which you have to learn first (and maybe learn again when your
vendor decides to `enhance' it).  With GiNaC you can write your program
in common C++, which is standardized.

@cindex STL
@item
structured data types: you can build up structured data types using
@code{struct}s or @code{class}es together with STL features instead of
using unnamed lists of lists of lists.

@item
strongly typed: in CAS, you usually have only one kind of variables
which can hold contents of an arbitrary type.  This 4GL like feature is
nice for novice programmers, but dangerous.
    
@item
development tools: powerful development tools exist for C++, like fancy
editors (e.g. with automatic indentation and syntax highlighting),
debuggers, visualization tools, documentation generators@dots{}

@item
modularization: C++ programs can easily be split into modules by
separating interface and implementation.

@item
price: GiNaC is distributed under the GNU Public License which means
that it is free and available with source code.  And there are excellent
C++-compilers for free, too.
    
@item
extendable: you can add your own classes to GiNaC, thus extending it on
a very low level.  Compare this to a traditional CAS that you can
usually only extend on a high level by writing in the language defined
by the parser.  In particular, it turns out to be almost impossible to
fix bugs in a traditional system.

@item
multiple interfaces: Though real GiNaC programs have to be written in
some editor, then be compiled, linked and executed, there are more ways
to work with the GiNaC engine.  Many people want to play with
expressions interactively, as in traditional CASs.  Currently, two such
windows into GiNaC have been implemented and many more are possible: the
tiny @command{ginsh} that is part of the distribution exposes GiNaC's
types to a command line and second, as a more consistent approach, an
interactive interface to the Cint C++ interpreter has been put together
(called GiNaC-cint) that allows an interactive scripting interface
consistent with the C++ language.  It is available from the usual GiNaC
FTP-site.

@item
seamless integration: it is somewhere between difficult and impossible
to call CAS functions from within a program written in C++ or any other
programming language and vice versa.  With GiNaC, your symbolic routines
are part of your program.  You can easily call third party libraries,
e.g. for numerical evaluation or graphical interaction.  All other
approaches are much more cumbersome: they range from simply ignoring the
problem (i.e. @emph{Maple}) to providing a method for `embedding' the
system (i.e. @emph{Yacas}).

@item
efficiency: often large parts of a program do not need symbolic
calculations at all.  Why use large integers for loop variables or
arbitrary precision arithmetics where @code{int} and @code{double} are
sufficient?  For pure symbolic applications, GiNaC is comparable in
speed with other CAS.

@end itemize


@node Disadvantages, Why C++?, Advantages, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Disadvantages

Of course it also has some disadvantages:

@itemize @bullet

@item
advanced features: GiNaC cannot compete with a program like
@emph{Reduce} which exists for more than 30 years now or @emph{Maple}
which grows since 1981 by the work of dozens of programmers, with
respect to mathematical features.  Integration, factorization,
non-trivial simplifications, limits etc. are missing in GiNaC (and are
not planned for the near future).

@item
portability: While the GiNaC library itself is designed to avoid any
platform dependent features (it should compile on any ANSI compliant C++
compiler), the currently used version of the CLN library (fast large
integer and arbitrary precision arithmetics) can only by compiled
without hassle on systems with the C++ compiler from the GNU Compiler
Collection (GCC).@footnote{This is because CLN uses PROVIDE/REQUIRE like
macros to let the compiler gather all static initializations, which
works for GNU C++ only.  Feel free to contact the authors in case you
really believe that you need to use a different compiler.  We have
occasionally used other compilers and may be able to give you advice.}
GiNaC uses recent language features like explicit constructors, mutable
members, RTTI, @code{dynamic_cast}s and STL, so ANSI compliance is meant
literally.  Recent GCC versions starting at 2.95.3, although itself not
yet ANSI compliant, support all needed features.
    
@end itemize


@node Why C++?, Internal Structures, Disadvantages, A Comparison With Other CAS
@c    node-name, next, previous, up
@section Why C++?

Why did we choose to implement GiNaC in C++ instead of Java or any other
language?  C++ is not perfect: type checking is not strict (casting is
possible), separation between interface and implementation is not
complete, object oriented design is not enforced.  The main reason is
the often scolded feature of operator overloading in C++.  While it may
be true that operating on classes with a @code{+} operator is rarely
meaningful, it is perfectly suited for algebraic expressions.  Writing
@math{3x+5y} as @code{3*x+5*y} instead of
@code{x.times(3).plus(y.times(5))} looks much more natural.
Furthermore, the main developers are more familiar with C++ than with
any other programming language.


@node Internal Structures, Expressions are reference counted, Why C++? , Top
@c    node-name, next, previous, up
@appendix Internal Structures

@menu
* Expressions are reference counted::
* Internal representation of products and sums::
@end menu

@node Expressions are reference counted, Internal representation of products and sums, Internal Structures, Internal Structures
@c    node-name, next, previous, up
@appendixsection Expressions are reference counted

@cindex reference counting
@cindex copy-on-write
@cindex garbage collection
An expression is extremely light-weight since internally it works like a
handle to the actual representation and really holds nothing more than a
pointer to some other object.  What this means in practice is that
whenever you create two @code{ex} and set the second equal to the first
no copying process is involved. Instead, the copying takes place as soon
as you try to change the second.  Consider the simple sequence of code:

@example
#include <iostream>
#include <ginac/ginac.h>
using namespace std;
using namespace GiNaC;

int main()
@{
    symbol x("x"), y("y"), z("z");
    ex e1, e2;

    e1 = sin(x + 2*y) + 3*z + 41;
    e2 = e1;                // e2 points to same object as e1
    cout << e2 << endl;     // prints sin(x+2*y)+3*z+41
    e2 += 1;                // e2 is copied into a new object
    cout << e2 << endl;     // prints sin(x+2*y)+3*z+42
@}
@end example

The line @code{e2 = e1;} creates a second expression pointing to the
object held already by @code{e1}.  The time involved for this operation
is therefore constant, no matter how large @code{e1} was.  Actual
copying, however, must take place in the line @code{e2 += 1;} because
@code{e1} and @code{e2} are not handles for the same object any more.
This concept is called @dfn{copy-on-write semantics}.  It increases
performance considerably whenever one object occurs multiple times and
represents a simple garbage collection scheme because when an @code{ex}
runs out of scope its destructor checks whether other expressions handle
the object it points to too and deletes the object from memory if that
turns out not to be the case.  A slightly less trivial example of
differentiation using the chain-rule should make clear how powerful this
can be:

@example
@{
    symbol x("x"), y("y");

    ex e1 = x + 3*y;
    ex e2 = pow(e1, 3);
    ex e3 = diff(sin(e2), x);   // first derivative of sin(e2) by x
    cout << e1 << endl          // prints x+3*y
         << e2 << endl          // prints (x+3*y)^3
         << e3 << endl;         // prints 3*(x+3*y)^2*cos((x+3*y)^3)
@}
@end example

Here, @code{e1} will actually be referenced three times while @code{e2}
will be referenced two times.  When the power of an expression is built,
that expression needs not be copied.  Likewise, since the derivative of
a power of an expression can be easily expressed in terms of that
expression, no copying of @code{e1} is involved when @code{e3} is
constructed.  So, when @code{e3} is constructed it will print as
@code{3*(x+3*y)^2*cos((x+3*y)^3)} but the argument of @code{cos()} only
holds a reference to @code{e2} and the factor in front is just
@code{3*e1^2}.

As a user of GiNaC, you cannot see this mechanism of copy-on-write
semantics.  When you insert an expression into a second expression, the
result behaves exactly as if the contents of the first expression were
inserted.  But it may be useful to remember that this is not what
happens.  Knowing this will enable you to write much more efficient
code.  If you still have an uncertain feeling with copy-on-write
semantics, we recommend you have a look at the
@uref{http://www.cerfnet.com/~mpcline/c++-faq-lite/, C++-FAQ lite} by
Marshall Cline.  Chapter 16 covers this issue and presents an
implementation which is pretty close to the one in GiNaC.


@node Internal representation of products and sums, Package Tools, Expressions are reference counted, Internal Structures
@c    node-name, next, previous, up
@appendixsection Internal representation of products and sums

@cindex representation
@cindex @code{add}
@cindex @code{mul}
@cindex @code{power}
Although it should be completely transparent for the user of
GiNaC a short discussion of this topic helps to understand the sources
and also explain performance to a large degree.  Consider the 
unexpanded symbolic expression 
@tex
$2d^3 \left( 4a + 5b - 3 \right)$
@end tex
@ifnottex
@math{2*d^3*(4*a+5*b-3)}
@end ifnottex
which could naively be represented by a tree of linear containers for
addition and multiplication, one container for exponentiation with base
and exponent and some atomic leaves of symbols and numbers in this
fashion:

@image{repnaive}

@cindex pair-wise representation
However, doing so results in a rather deeply nested tree which will
quickly become inefficient to manipulate.  We can improve on this by
representing the sum as a sequence of terms, each one being a pair of a
purely numeric multiplicative coefficient and its rest.  In the same
spirit we can store the multiplication as a sequence of terms, each
having a numeric exponent and a possibly complicated base, the tree
becomes much more flat:

@image{reppair}

The number @code{3} above the symbol @code{d} shows that @code{mul}
objects are treated similarly where the coefficients are interpreted as
@emph{exponents} now.  Addition of sums of terms or multiplication of
products with numerical exponents can be coded to be very efficient with
such a pair-wise representation.  Internally, this handling is performed
by most CAS in this way.  It typically speeds up manipulations by an
order of magnitude.  The overall multiplicative factor @code{2} and the
additive term @code{-3} look somewhat out of place in this
representation, however, since they are still carrying a trivial
exponent and multiplicative factor @code{1} respectively.  Within GiNaC,
this is avoided by adding a field that carries an overall numeric
coefficient.  This results in the realistic picture of internal
representation for
@tex
$2d^3 \left( 4a + 5b - 3 \right)$:
@end tex
@ifnottex
@math{2*d^3*(4*a+5*b-3)}:
@end ifnottex

@image{repreal}

@cindex radical
This also allows for a better handling of numeric radicals, since
@code{sqrt(2)} can now be carried along calculations.  Now it should be
clear, why both classes @code{add} and @code{mul} are derived from the
same abstract class: the data representation is the same, only the
semantics differs.  In the class hierarchy, methods for polynomial
expansion and the like are reimplemented for @code{add} and @code{mul},
but the data structure is inherited from @code{expairseq}.


@node Package Tools, ginac-config, Internal representation of products and sums, Top
@c    node-name, next, previous, up
@appendix Package Tools

If you are creating a software package that uses the GiNaC library,
setting the correct command line options for the compiler and linker
can be difficult. GiNaC includes two tools to make this process easier.

@menu
* ginac-config::   A shell script to detect compiler and linker flags.
* AM_PATH_GINAC::  Macro for GNU automake.
@end menu


@node ginac-config, AM_PATH_GINAC, Package Tools, Package Tools
@c    node-name, next, previous, up
@section @command{ginac-config}
@cindex ginac-config

@command{ginac-config} is a shell script that you can use to determine
the compiler and linker command line options required to compile and
link a program with the GiNaC library.

@command{ginac-config} takes the following flags:

@table @samp
@item --version
Prints out the version of GiNaC installed.
@item --cppflags
Prints '-I' flags pointing to the installed header files.
@item --libs
Prints out the linker flags necessary to link a program against GiNaC.
@item --prefix[=@var{PREFIX}]
If @var{PREFIX} is specified, overrides the configured value of @env{$prefix}.
(And of exec-prefix, unless @code{--exec-prefix} is also specified)
Otherwise, prints out the configured value of @env{$prefix}.
@item --exec-prefix[=@var{PREFIX}]
If @var{PREFIX} is specified, overrides the configured value of @env{$exec_prefix}.
Otherwise, prints out the configured value of @env{$exec_prefix}.
@end table

Typically, @command{ginac-config} will be used within a configure
script, as described below. It, however, can also be used directly from
the command line using backquotes to compile a simple program. For
example:

@example
c++ -o simple `ginac-config --cppflags` simple.cpp `ginac-config --libs`
@end example

This command line might expand to (for example):

@example
cc -o simple -I/usr/local/include simple.cpp -L/usr/local/lib \
  -lginac -lcln -lstdc++
@end example

Not only is the form using @command{ginac-config} easier to type, it will
work on any system, no matter how GiNaC was configured.


@node AM_PATH_GINAC, Configure script options, ginac-config, Package Tools
@c    node-name, next, previous, up
@section @samp{AM_PATH_GINAC}
@cindex AM_PATH_GINAC

For packages configured using GNU automake, GiNaC also provides
a macro to automate the process of checking for GiNaC.

@example
AM_PATH_GINAC([@var{MINIMUM-VERSION}, [@var{ACTION-IF-FOUND} [, @var{ACTION-IF-NOT-FOUND}]]])
@end example

This macro:

@itemize @bullet

@item
Determines the location of GiNaC using @command{ginac-config}, which is
either found in the user's path, or from the environment variable
@env{GINACLIB_CONFIG}.

@item
Tests the installed libraries to make sure that their version
is later than @var{MINIMUM-VERSION}. (A default version will be used
if not specified)

@item
If the required version was found, sets the @env{GINACLIB_CPPFLAGS} variable
to the output of @command{ginac-config --cppflags} and the @env{GINACLIB_LIBS}
variable to the output of @command{ginac-config --libs}, and calls
@samp{AC_SUBST()} for these variables so they can be used in generated
makefiles, and then executes @var{ACTION-IF-FOUND}.

@item
If the required version was not found, sets @env{GINACLIB_CPPFLAGS} and
@env{GINACLIB_LIBS} to empty strings, and executes @var{ACTION-IF-NOT-FOUND}.

@end itemize

This macro is in file @file{ginac.m4} which is installed in
@file{$datadir/aclocal}. Note that if automake was installed with a
different @samp{--prefix} than GiNaC, you will either have to manually
move @file{ginac.m4} to automake's @file{$datadir/aclocal}, or give
aclocal the @samp{-I} option when running it.

@menu
* Configure script options::  Configuring a package that uses AM_PATH_GINAC.
* Example package::           Example of a package using AM_PATH_GINAC.
@end menu


@node Configure script options, Example package, AM_PATH_GINAC, AM_PATH_GINAC
@c    node-name, next, previous, up
@subsection Configuring a package that uses @samp{AM_PATH_GINAC}

Simply make sure that @command{ginac-config} is in your path, and run
the configure script.

Notes:

@itemize @bullet

@item
The directory where the GiNaC libraries are installed needs
to be found by your system's dynamic linker.
  
This is generally done by

@display
editing @file{/etc/ld.so.conf} and running @command{ldconfig}
@end display

or by
   
@display
setting the environment variable @env{LD_LIBRARY_PATH},
@end display

or, as a last resort, 
 
@display
giving a @samp{-R} or @samp{-rpath} flag (depending on your linker) when
running configure, for instance:

@example
LDFLAGS=-R/home/cbauer/lib ./configure
@end example
@end display

@item
You can also specify a @command{ginac-config} not in your path by
setting the @env{GINACLIB_CONFIG} environment variable to the
name of the executable

@item
If you move the GiNaC package from its installed location,
you will either need to modify @command{ginac-config} script
manually to point to the new location or rebuild GiNaC.

@end itemize

Advanced note:

@itemize @bullet
@item
configure flags
  
@example
--with-ginac-prefix=@var{PREFIX}
--with-ginac-exec-prefix=@var{PREFIX}
@end example

are provided to override the prefix and exec-prefix that were stored
in the @command{ginac-config} shell script by GiNaC's configure. You are
generally better off configuring GiNaC with the right path to begin with.
@end itemize


@node Example package, Bibliography, Configure script options, AM_PATH_GINAC
@c    node-name, next, previous, up
@subsection Example of a package using @samp{AM_PATH_GINAC}

The following shows how to build a simple package using automake
and the @samp{AM_PATH_GINAC} macro. The program used here is @file{simple.cpp}:

@example
#include <ginac/ginac.h>

int main(void)
@{
    GiNaC::symbol x("x");
    GiNaC::ex a = GiNaC::sin(x);
    std::cout << "Derivative of " << a 
              << " is " << a.diff(x) << std::endl;
    return 0;
@}
@end example

You should first read the introductory portions of the automake
Manual, if you are not already familiar with it.

Two files are needed, @file{configure.in}, which is used to build the
configure script:

@example
dnl Process this file with autoconf to produce a configure script.
AC_INIT(simple.cpp)
AM_INIT_AUTOMAKE(simple.cpp, 1.0.0)

AC_PROG_CXX
AC_PROG_INSTALL
AC_LANG_CPLUSPLUS

AM_PATH_GINAC(0.9.0, [
  LIBS="$LIBS $GINACLIB_LIBS"
  CPPFLAGS="$CPPFLAGS $GINACLIB_CPPFLAGS"  
], AC_MSG_ERROR([need to have GiNaC installed]))

AC_OUTPUT(Makefile)
@end example

The only command in this which is not standard for automake
is the @samp{AM_PATH_GINAC} macro.

That command does the following: If a GiNaC version greater or equal
than 0.7.0 is found, then it adds @env{$GINACLIB_LIBS} to @env{$LIBS}
and @env{$GINACLIB_CPPFLAGS} to @env{$CPPFLAGS}. Otherwise, it dies with
the error message `need to have GiNaC installed'

And the @file{Makefile.am}, which will be used to build the Makefile.

@example
## Process this file with automake to produce Makefile.in
bin_PROGRAMS = simple
simple_SOURCES = simple.cpp
@end example

This @file{Makefile.am}, says that we are building a single executable,
from a single sourcefile @file{simple.cpp}. Since every program
we are building uses GiNaC we simply added the GiNaC options
to @env{$LIBS} and @env{$CPPFLAGS}, but in other circumstances, we might
want to specify them on a per-program basis: for instance by
adding the lines:

@example
simple_LDADD = $(GINACLIB_LIBS)
INCLUDES = $(GINACLIB_CPPFLAGS)
@end example

to the @file{Makefile.am}.

To try this example out, create a new directory and add the three
files above to it.

Now execute the following commands:

@example
$ automake --add-missing
$ aclocal
$ autoconf
@end example

You now have a package that can be built in the normal fashion

@example
$ ./configure
$ make
$ make install
@end example


@node Bibliography, Concept Index, Example package, Top
@c    node-name, next, previous, up
@appendix Bibliography

@itemize @minus{}

@item
@cite{ISO/IEC 14882:1998: Programming Languages: C++}

@item
@cite{CLN: A Class Library for Numbers}, @email{haible@@ilog.fr, Bruno Haible}

@item
@cite{The C++ Programming Language}, Bjarne Stroustrup, 3rd Edition, ISBN 0-201-88954-4, Addison Wesley

@item
@cite{C++ FAQs}, Marshall Cline, ISBN 0-201-58958-3, 1995, Addison Wesley

@item
@cite{Algorithms for Computer Algebra}, Keith O. Geddes, Stephen R. Czapor,
and George Labahn, ISBN 0-7923-9259-0, 1992, Kluwer Academic Publishers, Norwell, Massachusetts

@item
@cite{Computer Algebra: Systems and Algorithms for Algebraic Computation},
James H. Davenport, Yvon Siret, and Evelyne Tournier, ISBN 0-12-204230-1, 1988, 
Academic Press, London

@item
@cite{Computer Algebra Systems - A Practical Guide},
Michael J. Wester (editor), ISBN 0-471-98353-5, 1999, Wiley, Chichester

@item
@cite{The Art of Computer Programming, Vol 2: Seminumerical Algorithms},
Donald E. Knuth, ISBN 0-201-89684-2, 1998, Addison Wesley

@item
@cite{The Role of gamma5 in Dimensional Regularization}, Dirk Kreimer, hep-ph/9401354

@end itemize


@node Concept Index, , Bibliography, Top
@c    node-name, next, previous, up
@unnumbered Concept Index

@printindex cp

@bye
